{"ast":null,"code":"/**\n * This is a single-layer [Perceptron Classifier](http://en.wikipedia.org/wiki/Perceptron) that takes\n * arrays of numbers and predicts whether they should be classified\n * as either 0 or 1 (negative or positive examples).\n * @class\n * @example\n * // Create the model\n * var p = new PerceptronModel();\n * // Train the model with input with a diagonal boundary.\n * for (var i = 0; i < 5; i++) {\n *     p.train([1, 1], 1);\n *     p.train([0, 1], 0);\n *     p.train([1, 0], 0);\n *     p.train([0, 0], 0);\n * }\n * p.predict([0, 0]); // 0\n * p.predict([0, 1]); // 0\n * p.predict([1, 0]); // 0\n * p.predict([1, 1]); // 1\n */\nclass PerceptronModel {\n  /*:: bias: number */\n  /*:: weights: Array<number> */\n  constructor() {\n    // The weights, or coefficients of the model;\n    // weights are only populated when training with data.\n    this.weights = [];\n    // The bias term, or intercept; it is also a weight but\n    // it's stored separately for convenience as it is always\n    // multiplied by one.\n    this.bias = 0;\n  }\n  /**\n   * **Predict**: Use an array of features with the weight array and bias\n   * to predict whether an example is labeled 0 or 1.\n   *\n   * @param {Array<number>} features an array of features as numbers\n   * @returns {number} 1 if the score is over 0, otherwise 0\n   */\n  predict(features) {\n    // Only predict if previously trained\n    // on the same size feature array(s).\n    if (features.length !== this.weights.length) {\n      return null;\n    }\n\n    // Calculate the sum of features times weights,\n    // with the bias added (implicitly times one).\n    let score = 0;\n    for (let i = 0; i < this.weights.length; i++) {\n      score += this.weights[i] * features[i];\n    }\n    score += this.bias;\n\n    // Classify as 1 if the score is over 0, otherwise 0.\n    if (score > 0) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n\n  /**\n   * **Train** the classifier with a new example, which is\n   * a numeric array of features and a 0 or 1 label.\n   *\n   * @param {Array<number>} features an array of features as numbers\n   * @param {number} label either 0 or 1\n   * @returns {PerceptronModel} this\n   */\n  train(features, label) {\n    // Require that only labels of 0 or 1 are considered.\n    if (label !== 0 && label !== 1) {\n      return null;\n    }\n    // The length of the feature array determines\n    // the length of the weight array.\n    // The perceptron will continue learning as long as\n    // it keeps seeing feature arrays of the same length.\n    // When it sees a new data shape, it initializes.\n    if (features.length !== this.weights.length) {\n      this.weights = features;\n      this.bias = 1;\n    }\n    // Make a prediction based on current weights.\n    const prediction = this.predict(features);\n    // Update the weights if the prediction is wrong.\n    if (typeof prediction === \"number\" && prediction !== label) {\n      const gradient = label - prediction;\n      for (let i = 0; i < this.weights.length; i++) {\n        this.weights[i] += gradient * features[i];\n      }\n      this.bias += gradient;\n    }\n    return this;\n  }\n}\nexport default PerceptronModel;","map":{"version":3,"names":["PerceptronModel","constructor","weights","bias","predict","features","length","score","i","train","label","prediction","gradient"],"sources":["C:/ProPython/Stock2/node_modules/simple-statistics/src/perceptron.js"],"sourcesContent":["/**\n * This is a single-layer [Perceptron Classifier](http://en.wikipedia.org/wiki/Perceptron) that takes\n * arrays of numbers and predicts whether they should be classified\n * as either 0 or 1 (negative or positive examples).\n * @class\n * @example\n * // Create the model\n * var p = new PerceptronModel();\n * // Train the model with input with a diagonal boundary.\n * for (var i = 0; i < 5; i++) {\n *     p.train([1, 1], 1);\n *     p.train([0, 1], 0);\n *     p.train([1, 0], 0);\n *     p.train([0, 0], 0);\n * }\n * p.predict([0, 0]); // 0\n * p.predict([0, 1]); // 0\n * p.predict([1, 0]); // 0\n * p.predict([1, 1]); // 1\n */\nclass PerceptronModel {\n    /*:: bias: number */\n    /*:: weights: Array<number> */\n    constructor() {\n        // The weights, or coefficients of the model;\n        // weights are only populated when training with data.\n        this.weights = [];\n        // The bias term, or intercept; it is also a weight but\n        // it's stored separately for convenience as it is always\n        // multiplied by one.\n        this.bias = 0;\n    }\n    /**\n     * **Predict**: Use an array of features with the weight array and bias\n     * to predict whether an example is labeled 0 or 1.\n     *\n     * @param {Array<number>} features an array of features as numbers\n     * @returns {number} 1 if the score is over 0, otherwise 0\n     */\n    predict(features) {\n        // Only predict if previously trained\n        // on the same size feature array(s).\n        if (features.length !== this.weights.length) {\n            return null;\n        }\n\n        // Calculate the sum of features times weights,\n        // with the bias added (implicitly times one).\n        let score = 0;\n        for (let i = 0; i < this.weights.length; i++) {\n            score += this.weights[i] * features[i];\n        }\n        score += this.bias;\n\n        // Classify as 1 if the score is over 0, otherwise 0.\n        if (score > 0) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * **Train** the classifier with a new example, which is\n     * a numeric array of features and a 0 or 1 label.\n     *\n     * @param {Array<number>} features an array of features as numbers\n     * @param {number} label either 0 or 1\n     * @returns {PerceptronModel} this\n     */\n    train(features, label) {\n        // Require that only labels of 0 or 1 are considered.\n        if (label !== 0 && label !== 1) {\n            return null;\n        }\n        // The length of the feature array determines\n        // the length of the weight array.\n        // The perceptron will continue learning as long as\n        // it keeps seeing feature arrays of the same length.\n        // When it sees a new data shape, it initializes.\n        if (features.length !== this.weights.length) {\n            this.weights = features;\n            this.bias = 1;\n        }\n        // Make a prediction based on current weights.\n        const prediction = this.predict(features);\n        // Update the weights if the prediction is wrong.\n        if (typeof prediction === \"number\" && prediction !== label) {\n            const gradient = label - prediction;\n            for (let i = 0; i < this.weights.length; i++) {\n                this.weights[i] += gradient * features[i];\n            }\n            this.bias += gradient;\n        }\n        return this;\n    }\n}\n\nexport default PerceptronModel;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,eAAe,CAAC;EAClB;EACA;EACAC,WAAWA,CAAA,EAAG;IACV;IACA;IACA,IAAI,CAACC,OAAO,GAAG,EAAE;IACjB;IACA;IACA;IACA,IAAI,CAACC,IAAI,GAAG,CAAC;EACjB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIC,OAAOA,CAACC,QAAQ,EAAE;IACd;IACA;IACA,IAAIA,QAAQ,CAACC,MAAM,KAAK,IAAI,CAACJ,OAAO,CAACI,MAAM,EAAE;MACzC,OAAO,IAAI;IACf;;IAEA;IACA;IACA,IAAIC,KAAK,GAAG,CAAC;IACb,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACN,OAAO,CAACI,MAAM,EAAEE,CAAC,EAAE,EAAE;MAC1CD,KAAK,IAAI,IAAI,CAACL,OAAO,CAACM,CAAC,CAAC,GAAGH,QAAQ,CAACG,CAAC,CAAC;IAC1C;IACAD,KAAK,IAAI,IAAI,CAACJ,IAAI;;IAElB;IACA,IAAII,KAAK,GAAG,CAAC,EAAE;MACX,OAAO,CAAC;IACZ,CAAC,MAAM;MACH,OAAO,CAAC;IACZ;EACJ;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,KAAKA,CAACJ,QAAQ,EAAEK,KAAK,EAAE;IACnB;IACA,IAAIA,KAAK,KAAK,CAAC,IAAIA,KAAK,KAAK,CAAC,EAAE;MAC5B,OAAO,IAAI;IACf;IACA;IACA;IACA;IACA;IACA;IACA,IAAIL,QAAQ,CAACC,MAAM,KAAK,IAAI,CAACJ,OAAO,CAACI,MAAM,EAAE;MACzC,IAAI,CAACJ,OAAO,GAAGG,QAAQ;MACvB,IAAI,CAACF,IAAI,GAAG,CAAC;IACjB;IACA;IACA,MAAMQ,UAAU,GAAG,IAAI,CAACP,OAAO,CAACC,QAAQ,CAAC;IACzC;IACA,IAAI,OAAOM,UAAU,KAAK,QAAQ,IAAIA,UAAU,KAAKD,KAAK,EAAE;MACxD,MAAME,QAAQ,GAAGF,KAAK,GAAGC,UAAU;MACnC,KAAK,IAAIH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACN,OAAO,CAACI,MAAM,EAAEE,CAAC,EAAE,EAAE;QAC1C,IAAI,CAACN,OAAO,CAACM,CAAC,CAAC,IAAII,QAAQ,GAAGP,QAAQ,CAACG,CAAC,CAAC;MAC7C;MACA,IAAI,CAACL,IAAI,IAAIS,QAAQ;IACzB;IACA,OAAO,IAAI;EACf;AACJ;AAEA,eAAeZ,eAAe","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}