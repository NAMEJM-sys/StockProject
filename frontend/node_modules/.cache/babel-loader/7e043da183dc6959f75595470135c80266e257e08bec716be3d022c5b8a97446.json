{"ast":null,"code":"import factorial from \"./factorial.js\";\n\n/**\n * Compute the [gamma function](https://en.wikipedia.org/wiki/Gamma_function) of a value using Nemes' approximation.\n * The gamma of n is equivalent to (n-1)!, but unlike the factorial function, gamma is defined for all real n except zero\n * and negative integers (where NaN is returned). Note, the gamma function is also well-defined for complex numbers,\n * though this implementation currently does not handle complex numbers as input values.\n * Nemes' approximation is defined [here](https://arxiv.org/abs/1003.6020) as Theorem 2.2.\n * Negative values use [Euler's reflection formula](https://en.wikipedia.org/wiki/Gamma_function#Properties) for computation.\n *\n * @param {number} n Any real number except for zero and negative integers.\n * @returns {number} The gamma of the input value.\n *\n * @example\n * gamma(11.5); // 11899423.084037038\n * gamma(-11.5); // 2.29575810481609e-8\n * gamma(5); // 24\n */\nfunction gamma(n) {\n  if (Number.isInteger(n)) {\n    if (n <= 0) {\n      // gamma not defined for zero or negative integers\n      return Number.NaN;\n    } else {\n      // use factorial for integer inputs\n      return factorial(n - 1);\n    }\n  }\n\n  // Decrement n, because approximation is defined for n - 1\n  n--;\n  if (n < 0) {\n    // Use Euler's reflection formula for negative inputs\n    // see:  https://en.wikipedia.org/wiki/Gamma_function#Properties\n    return Math.PI / (Math.sin(Math.PI * -n) * gamma(-n));\n  } else {\n    // Nemes' expansion approximation\n    const seriesCoefficient = Math.pow(n / Math.E, n) * Math.sqrt(2 * Math.PI * (n + 1 / 6));\n    const seriesDenom = n + 1 / 4;\n    const seriesExpansion = 1 + 1 / 144 / Math.pow(seriesDenom, 2) - 1 / 12960 / Math.pow(seriesDenom, 3) - 257 / 207360 / Math.pow(seriesDenom, 4) - 52 / 2612736 / Math.pow(seriesDenom, 5) + 5741173 / 9405849600 / Math.pow(seriesDenom, 6) + 37529 / 18811699200 / Math.pow(seriesDenom, 7);\n    return seriesCoefficient * seriesExpansion;\n  }\n}\nexport default gamma;","map":{"version":3,"names":["factorial","gamma","n","Number","isInteger","NaN","Math","PI","sin","seriesCoefficient","pow","E","sqrt","seriesDenom","seriesExpansion"],"sources":["C:/ProPython/Stock2/node_modules/simple-statistics/src/gamma.js"],"sourcesContent":["import factorial from \"./factorial.js\";\n\n/**\n * Compute the [gamma function](https://en.wikipedia.org/wiki/Gamma_function) of a value using Nemes' approximation.\n * The gamma of n is equivalent to (n-1)!, but unlike the factorial function, gamma is defined for all real n except zero\n * and negative integers (where NaN is returned). Note, the gamma function is also well-defined for complex numbers,\n * though this implementation currently does not handle complex numbers as input values.\n * Nemes' approximation is defined [here](https://arxiv.org/abs/1003.6020) as Theorem 2.2.\n * Negative values use [Euler's reflection formula](https://en.wikipedia.org/wiki/Gamma_function#Properties) for computation.\n *\n * @param {number} n Any real number except for zero and negative integers.\n * @returns {number} The gamma of the input value.\n *\n * @example\n * gamma(11.5); // 11899423.084037038\n * gamma(-11.5); // 2.29575810481609e-8\n * gamma(5); // 24\n */\nfunction gamma(n) {\n    if (Number.isInteger(n)) {\n        if (n <= 0) {\n            // gamma not defined for zero or negative integers\n            return Number.NaN;\n        } else {\n            // use factorial for integer inputs\n            return factorial(n - 1);\n        }\n    }\n\n    // Decrement n, because approximation is defined for n - 1\n    n--;\n\n    if (n < 0) {\n        // Use Euler's reflection formula for negative inputs\n        // see:  https://en.wikipedia.org/wiki/Gamma_function#Properties\n        return Math.PI / (Math.sin(Math.PI * -n) * gamma(-n));\n    } else {\n        // Nemes' expansion approximation\n        const seriesCoefficient =\n            Math.pow(n / Math.E, n) * Math.sqrt(2 * Math.PI * (n + 1 / 6));\n\n        const seriesDenom = n + 1 / 4;\n\n        const seriesExpansion =\n            1 +\n            1 / 144 / Math.pow(seriesDenom, 2) -\n            1 / 12960 / Math.pow(seriesDenom, 3) -\n            257 / 207360 / Math.pow(seriesDenom, 4) -\n            52 / 2612736 / Math.pow(seriesDenom, 5) +\n            5741173 / 9405849600 / Math.pow(seriesDenom, 6) +\n            37529 / 18811699200 / Math.pow(seriesDenom, 7);\n\n        return seriesCoefficient * seriesExpansion;\n    }\n}\n\nexport default gamma;\n"],"mappings":"AAAA,OAAOA,SAAS,MAAM,gBAAgB;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,KAAKA,CAACC,CAAC,EAAE;EACd,IAAIC,MAAM,CAACC,SAAS,CAACF,CAAC,CAAC,EAAE;IACrB,IAAIA,CAAC,IAAI,CAAC,EAAE;MACR;MACA,OAAOC,MAAM,CAACE,GAAG;IACrB,CAAC,MAAM;MACH;MACA,OAAOL,SAAS,CAACE,CAAC,GAAG,CAAC,CAAC;IAC3B;EACJ;;EAEA;EACAA,CAAC,EAAE;EAEH,IAAIA,CAAC,GAAG,CAAC,EAAE;IACP;IACA;IACA,OAAOI,IAAI,CAACC,EAAE,IAAID,IAAI,CAACE,GAAG,CAACF,IAAI,CAACC,EAAE,GAAG,CAACL,CAAC,CAAC,GAAGD,KAAK,CAAC,CAACC,CAAC,CAAC,CAAC;EACzD,CAAC,MAAM;IACH;IACA,MAAMO,iBAAiB,GACnBH,IAAI,CAACI,GAAG,CAACR,CAAC,GAAGI,IAAI,CAACK,CAAC,EAAET,CAAC,CAAC,GAAGI,IAAI,CAACM,IAAI,CAAC,CAAC,GAAGN,IAAI,CAACC,EAAE,IAAIL,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;IAElE,MAAMW,WAAW,GAAGX,CAAC,GAAG,CAAC,GAAG,CAAC;IAE7B,MAAMY,eAAe,GACjB,CAAC,GACD,CAAC,GAAG,GAAG,GAAGR,IAAI,CAACI,GAAG,CAACG,WAAW,EAAE,CAAC,CAAC,GAClC,CAAC,GAAG,KAAK,GAAGP,IAAI,CAACI,GAAG,CAACG,WAAW,EAAE,CAAC,CAAC,GACpC,GAAG,GAAG,MAAM,GAAGP,IAAI,CAACI,GAAG,CAACG,WAAW,EAAE,CAAC,CAAC,GACvC,EAAE,GAAG,OAAO,GAAGP,IAAI,CAACI,GAAG,CAACG,WAAW,EAAE,CAAC,CAAC,GACvC,OAAO,GAAG,UAAU,GAAGP,IAAI,CAACI,GAAG,CAACG,WAAW,EAAE,CAAC,CAAC,GAC/C,KAAK,GAAG,WAAW,GAAGP,IAAI,CAACI,GAAG,CAACG,WAAW,EAAE,CAAC,CAAC;IAElD,OAAOJ,iBAAiB,GAAGK,eAAe;EAC9C;AACJ;AAEA,eAAeb,KAAK","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}