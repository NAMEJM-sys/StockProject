{"ast":null,"code":"/**\n * [Bayesian Classifier](http://en.wikipedia.org/wiki/Naive_Bayes_classifier)\n *\n * This is a naïve bayesian classifier that takes\n * singly-nested objects.\n *\n * @class\n * @example\n * var bayes = new BayesianClassifier();\n * bayes.train({\n *   species: 'Cat'\n * }, 'animal');\n * var result = bayes.score({\n *   species: 'Cat'\n * })\n * // result\n * // {\n * //   animal: 1\n * // }\n */\nclass BayesianClassifier {\n  /*:: totalCount: number */\n  /*:: data: Object */\n  constructor() {\n    // The number of items that are currently\n    // classified in the model\n    this.totalCount = 0;\n    // Every item classified in the model\n    this.data = {};\n  }\n\n  /**\n   * Train the classifier with a new item, which has a single\n   * dimension of Javascript literal keys and values.\n   *\n   * @param {Object} item an object with singly-deep properties\n   * @param {string} category the category this item belongs to\n   * @return {undefined} adds the item to the classifier\n   */\n  train(item, category) {\n    // If the data object doesn't have any values\n    // for this category, create a new object for it.\n    if (!this.data[category]) {\n      this.data[category] = {};\n    }\n\n    // Iterate through each key in the item.\n    for (const k in item) {\n      const v = item[k];\n      // Initialize the nested object `data[category][k][item[k]]`\n      // with an object of keys that equal 0.\n      if (this.data[category][k] === undefined) {\n        this.data[category][k] = {};\n      }\n      if (this.data[category][k][v] === undefined) {\n        this.data[category][k][v] = 0;\n      }\n\n      // And increment the key for this key/value combination.\n      this.data[category][k][v]++;\n    }\n\n    // Increment the number of items classified\n    this.totalCount++;\n  }\n\n  /**\n   * Generate a score of how well this item matches all\n   * possible categories based on its attributes\n   *\n   * @param {Object} item an item in the same format as with train\n   * @returns {Object} of probabilities that this item belongs to a\n   * given category.\n   */\n  score(item) {\n    // Initialize an empty array of odds per category.\n    const odds = {};\n    let category;\n    // Iterate through each key in the item,\n    // then iterate through each category that has been used\n    // in previous calls to `.train()`\n    for (const k in item) {\n      const v = item[k];\n      for (category in this.data) {\n        // Create an empty object for storing key - value combinations\n        // for this category.\n        odds[category] = {};\n\n        // If this item doesn't even have a property, it counts for nothing,\n        // but if it does have the property that we're looking for from\n        // the item to categorize, it counts based on how popular it is\n        // versus the whole population.\n        if (this.data[category][k]) {\n          odds[category][k + \"_\" + v] = (this.data[category][k][v] || 0) / this.totalCount;\n        } else {\n          odds[category][k + \"_\" + v] = 0;\n        }\n      }\n    }\n\n    // Set up a new object that will contain sums of these odds by category\n    const oddsSums = {};\n    for (category in odds) {\n      // Tally all of the odds for each category-combination pair -\n      // the non-existence of a category does not add anything to the\n      // score.\n      oddsSums[category] = 0;\n      for (const combination in odds[category]) {\n        oddsSums[category] += odds[category][combination];\n      }\n    }\n    return oddsSums;\n  }\n}\nexport default BayesianClassifier;","map":{"version":3,"names":["BayesianClassifier","constructor","totalCount","data","train","item","category","k","v","undefined","score","odds","oddsSums","combination"],"sources":["C:/ProPython/Stock2/node_modules/simple-statistics/src/bayesian_classifier.js"],"sourcesContent":["/**\n * [Bayesian Classifier](http://en.wikipedia.org/wiki/Naive_Bayes_classifier)\n *\n * This is a naïve bayesian classifier that takes\n * singly-nested objects.\n *\n * @class\n * @example\n * var bayes = new BayesianClassifier();\n * bayes.train({\n *   species: 'Cat'\n * }, 'animal');\n * var result = bayes.score({\n *   species: 'Cat'\n * })\n * // result\n * // {\n * //   animal: 1\n * // }\n */\nclass BayesianClassifier {\n    /*:: totalCount: number */\n    /*:: data: Object */\n    constructor() {\n        // The number of items that are currently\n        // classified in the model\n        this.totalCount = 0;\n        // Every item classified in the model\n        this.data = {};\n    }\n\n    /**\n     * Train the classifier with a new item, which has a single\n     * dimension of Javascript literal keys and values.\n     *\n     * @param {Object} item an object with singly-deep properties\n     * @param {string} category the category this item belongs to\n     * @return {undefined} adds the item to the classifier\n     */\n    train(item, category) {\n        // If the data object doesn't have any values\n        // for this category, create a new object for it.\n        if (!this.data[category]) {\n            this.data[category] = {};\n        }\n\n        // Iterate through each key in the item.\n        for (const k in item) {\n            const v = item[k];\n            // Initialize the nested object `data[category][k][item[k]]`\n            // with an object of keys that equal 0.\n            if (this.data[category][k] === undefined) {\n                this.data[category][k] = {};\n            }\n            if (this.data[category][k][v] === undefined) {\n                this.data[category][k][v] = 0;\n            }\n\n            // And increment the key for this key/value combination.\n            this.data[category][k][v]++;\n        }\n\n        // Increment the number of items classified\n        this.totalCount++;\n    }\n\n    /**\n     * Generate a score of how well this item matches all\n     * possible categories based on its attributes\n     *\n     * @param {Object} item an item in the same format as with train\n     * @returns {Object} of probabilities that this item belongs to a\n     * given category.\n     */\n    score(item) {\n        // Initialize an empty array of odds per category.\n        const odds = {};\n        let category;\n        // Iterate through each key in the item,\n        // then iterate through each category that has been used\n        // in previous calls to `.train()`\n        for (const k in item) {\n            const v = item[k];\n            for (category in this.data) {\n                // Create an empty object for storing key - value combinations\n                // for this category.\n                odds[category] = {};\n\n                // If this item doesn't even have a property, it counts for nothing,\n                // but if it does have the property that we're looking for from\n                // the item to categorize, it counts based on how popular it is\n                // versus the whole population.\n                if (this.data[category][k]) {\n                    odds[category][k + \"_\" + v] =\n                        (this.data[category][k][v] || 0) / this.totalCount;\n                } else {\n                    odds[category][k + \"_\" + v] = 0;\n                }\n            }\n        }\n\n        // Set up a new object that will contain sums of these odds by category\n        const oddsSums = {};\n\n        for (category in odds) {\n            // Tally all of the odds for each category-combination pair -\n            // the non-existence of a category does not add anything to the\n            // score.\n            oddsSums[category] = 0;\n            for (const combination in odds[category]) {\n                oddsSums[category] += odds[category][combination];\n            }\n        }\n\n        return oddsSums;\n    }\n}\n\nexport default BayesianClassifier;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,kBAAkB,CAAC;EACrB;EACA;EACAC,WAAWA,CAAA,EAAG;IACV;IACA;IACA,IAAI,CAACC,UAAU,GAAG,CAAC;IACnB;IACA,IAAI,CAACC,IAAI,GAAG,CAAC,CAAC;EAClB;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,KAAKA,CAACC,IAAI,EAAEC,QAAQ,EAAE;IAClB;IACA;IACA,IAAI,CAAC,IAAI,CAACH,IAAI,CAACG,QAAQ,CAAC,EAAE;MACtB,IAAI,CAACH,IAAI,CAACG,QAAQ,CAAC,GAAG,CAAC,CAAC;IAC5B;;IAEA;IACA,KAAK,MAAMC,CAAC,IAAIF,IAAI,EAAE;MAClB,MAAMG,CAAC,GAAGH,IAAI,CAACE,CAAC,CAAC;MACjB;MACA;MACA,IAAI,IAAI,CAACJ,IAAI,CAACG,QAAQ,CAAC,CAACC,CAAC,CAAC,KAAKE,SAAS,EAAE;QACtC,IAAI,CAACN,IAAI,CAACG,QAAQ,CAAC,CAACC,CAAC,CAAC,GAAG,CAAC,CAAC;MAC/B;MACA,IAAI,IAAI,CAACJ,IAAI,CAACG,QAAQ,CAAC,CAACC,CAAC,CAAC,CAACC,CAAC,CAAC,KAAKC,SAAS,EAAE;QACzC,IAAI,CAACN,IAAI,CAACG,QAAQ,CAAC,CAACC,CAAC,CAAC,CAACC,CAAC,CAAC,GAAG,CAAC;MACjC;;MAEA;MACA,IAAI,CAACL,IAAI,CAACG,QAAQ,CAAC,CAACC,CAAC,CAAC,CAACC,CAAC,CAAC,EAAE;IAC/B;;IAEA;IACA,IAAI,CAACN,UAAU,EAAE;EACrB;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIQ,KAAKA,CAACL,IAAI,EAAE;IACR;IACA,MAAMM,IAAI,GAAG,CAAC,CAAC;IACf,IAAIL,QAAQ;IACZ;IACA;IACA;IACA,KAAK,MAAMC,CAAC,IAAIF,IAAI,EAAE;MAClB,MAAMG,CAAC,GAAGH,IAAI,CAACE,CAAC,CAAC;MACjB,KAAKD,QAAQ,IAAI,IAAI,CAACH,IAAI,EAAE;QACxB;QACA;QACAQ,IAAI,CAACL,QAAQ,CAAC,GAAG,CAAC,CAAC;;QAEnB;QACA;QACA;QACA;QACA,IAAI,IAAI,CAACH,IAAI,CAACG,QAAQ,CAAC,CAACC,CAAC,CAAC,EAAE;UACxBI,IAAI,CAACL,QAAQ,CAAC,CAACC,CAAC,GAAG,GAAG,GAAGC,CAAC,CAAC,GACvB,CAAC,IAAI,CAACL,IAAI,CAACG,QAAQ,CAAC,CAACC,CAAC,CAAC,CAACC,CAAC,CAAC,IAAI,CAAC,IAAI,IAAI,CAACN,UAAU;QAC1D,CAAC,MAAM;UACHS,IAAI,CAACL,QAAQ,CAAC,CAACC,CAAC,GAAG,GAAG,GAAGC,CAAC,CAAC,GAAG,CAAC;QACnC;MACJ;IACJ;;IAEA;IACA,MAAMI,QAAQ,GAAG,CAAC,CAAC;IAEnB,KAAKN,QAAQ,IAAIK,IAAI,EAAE;MACnB;MACA;MACA;MACAC,QAAQ,CAACN,QAAQ,CAAC,GAAG,CAAC;MACtB,KAAK,MAAMO,WAAW,IAAIF,IAAI,CAACL,QAAQ,CAAC,EAAE;QACtCM,QAAQ,CAACN,QAAQ,CAAC,IAAIK,IAAI,CAACL,QAAQ,CAAC,CAACO,WAAW,CAAC;MACrD;IACJ;IAEA,OAAOD,QAAQ;EACnB;AACJ;AAEA,eAAeZ,kBAAkB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}