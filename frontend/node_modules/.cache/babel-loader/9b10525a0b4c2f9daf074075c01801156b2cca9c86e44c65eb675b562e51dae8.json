{"ast":null,"code":"import euclideanDistance from \"./euclidean_distance.js\";\nimport makeMatrix from \"./make_matrix.js\";\nimport sample from \"./sample.js\";\n\n/**\n * @typedef {Object} kMeansReturn\n * @property {Array<number>} labels The labels.\n * @property {Array<Array<number>>} centroids The cluster centroids.\n */\n\n/**\n * Perform k-means clustering.\n *\n * @param {Array<Array<number>>} points N-dimensional coordinates of points to be clustered.\n * @param {number} numCluster How many clusters to create.\n * @param {Function} randomSource An optional entropy source that generates uniform values in [0, 1).\n * @return {kMeansReturn} Labels (same length as data) and centroids (same length as numCluster).\n * @throws {Error} If any centroids wind up friendless (i.e., without associated points).\n *\n * @example\n * kMeansCluster([[0.0, 0.5], [1.0, 0.5]], 2); // => {labels: [0, 1], centroids: [[0.0, 0.5], [1.0 0.5]]}\n */\nfunction kMeansCluster(points, numCluster, randomSource = Math.random) {\n  let oldCentroids = null;\n  let newCentroids = sample(points, numCluster, randomSource);\n  let labels = null;\n  let change = Number.MAX_VALUE;\n  while (change !== 0) {\n    labels = labelPoints(points, newCentroids);\n    oldCentroids = newCentroids;\n    newCentroids = calculateCentroids(points, labels, numCluster);\n    change = calculateChange(newCentroids, oldCentroids);\n  }\n  return {\n    labels: labels,\n    centroids: newCentroids\n  };\n}\n\n/**\n * Label each point according to which centroid it is closest to.\n *\n * @private\n * @param {Array<Array<number>>} points Array of XY coordinates.\n * @param {Array<Array<number>>} centroids Current centroids.\n * @return {Array<number>} Group labels.\n */\nfunction labelPoints(points, centroids) {\n  return points.map(p => {\n    let minDist = Number.MAX_VALUE;\n    let label = -1;\n    for (let i = 0; i < centroids.length; i++) {\n      const dist = euclideanDistance(p, centroids[i]);\n      if (dist < minDist) {\n        minDist = dist;\n        label = i;\n      }\n    }\n    return label;\n  });\n}\n\n/**\n * Calculate centroids for points given labels.\n *\n * @private\n * @param {Array<Array<number>>} points Array of XY coordinates.\n * @param {Array<number>} labels Which groups points belong to.\n * @param {number} numCluster Number of clusters being created.\n * @return {Array<Array<number>>} Centroid for each group.\n * @throws {Error} If any centroids wind up friendless (i.e., without associated points).\n */\nfunction calculateCentroids(points, labels, numCluster) {\n  // Initialize accumulators.\n  const dimension = points[0].length;\n  const centroids = makeMatrix(numCluster, dimension);\n  const counts = Array(numCluster).fill(0);\n\n  // Add points to centroids' accumulators and count points per centroid.\n  const numPoints = points.length;\n  for (let i = 0; i < numPoints; i++) {\n    const point = points[i];\n    const label = labels[i];\n    const current = centroids[label];\n    for (let j = 0; j < dimension; j++) {\n      current[j] += point[j];\n    }\n    counts[label] += 1;\n  }\n\n  // Rescale centroids, checking for any that have no points.\n  for (let i = 0; i < numCluster; i++) {\n    if (counts[i] === 0) {\n      throw new Error(`Centroid ${i} has no friends`);\n    }\n    const centroid = centroids[i];\n    for (let j = 0; j < dimension; j++) {\n      centroid[j] /= counts[i];\n    }\n  }\n  return centroids;\n}\n\n/**\n * Calculate the difference between old centroids and new centroids.\n *\n * @private\n * @param {Array<Array<number>>} left One list of centroids.\n * @param {Array<Array<number>>} right Another list of centroids.\n * @return {number} Distance between centroids.\n */\nfunction calculateChange(left, right) {\n  let total = 0;\n  for (let i = 0; i < left.length; i++) {\n    total += euclideanDistance(left[i], right[i]);\n  }\n  return total;\n}\nexport default kMeansCluster;","map":{"version":3,"names":["euclideanDistance","makeMatrix","sample","kMeansCluster","points","numCluster","randomSource","Math","random","oldCentroids","newCentroids","labels","change","Number","MAX_VALUE","labelPoints","calculateCentroids","calculateChange","centroids","map","p","minDist","label","i","length","dist","dimension","counts","Array","fill","numPoints","point","current","j","Error","centroid","left","right","total"],"sources":["C:/ProPython/Stock2/node_modules/simple-statistics/src/k_means_cluster.js"],"sourcesContent":["import euclideanDistance from \"./euclidean_distance.js\";\nimport makeMatrix from \"./make_matrix.js\";\nimport sample from \"./sample.js\";\n\n/**\n * @typedef {Object} kMeansReturn\n * @property {Array<number>} labels The labels.\n * @property {Array<Array<number>>} centroids The cluster centroids.\n */\n\n/**\n * Perform k-means clustering.\n *\n * @param {Array<Array<number>>} points N-dimensional coordinates of points to be clustered.\n * @param {number} numCluster How many clusters to create.\n * @param {Function} randomSource An optional entropy source that generates uniform values in [0, 1).\n * @return {kMeansReturn} Labels (same length as data) and centroids (same length as numCluster).\n * @throws {Error} If any centroids wind up friendless (i.e., without associated points).\n *\n * @example\n * kMeansCluster([[0.0, 0.5], [1.0, 0.5]], 2); // => {labels: [0, 1], centroids: [[0.0, 0.5], [1.0 0.5]]}\n */\nfunction kMeansCluster(points, numCluster, randomSource = Math.random) {\n    let oldCentroids = null;\n    let newCentroids = sample(points, numCluster, randomSource);\n    let labels = null;\n    let change = Number.MAX_VALUE;\n    while (change !== 0) {\n        labels = labelPoints(points, newCentroids);\n        oldCentroids = newCentroids;\n        newCentroids = calculateCentroids(points, labels, numCluster);\n        change = calculateChange(newCentroids, oldCentroids);\n    }\n    return {\n        labels: labels,\n        centroids: newCentroids\n    };\n}\n\n/**\n * Label each point according to which centroid it is closest to.\n *\n * @private\n * @param {Array<Array<number>>} points Array of XY coordinates.\n * @param {Array<Array<number>>} centroids Current centroids.\n * @return {Array<number>} Group labels.\n */\nfunction labelPoints(points, centroids) {\n    return points.map((p) => {\n        let minDist = Number.MAX_VALUE;\n        let label = -1;\n        for (let i = 0; i < centroids.length; i++) {\n            const dist = euclideanDistance(p, centroids[i]);\n            if (dist < minDist) {\n                minDist = dist;\n                label = i;\n            }\n        }\n        return label;\n    });\n}\n\n/**\n * Calculate centroids for points given labels.\n *\n * @private\n * @param {Array<Array<number>>} points Array of XY coordinates.\n * @param {Array<number>} labels Which groups points belong to.\n * @param {number} numCluster Number of clusters being created.\n * @return {Array<Array<number>>} Centroid for each group.\n * @throws {Error} If any centroids wind up friendless (i.e., without associated points).\n */\nfunction calculateCentroids(points, labels, numCluster) {\n    // Initialize accumulators.\n    const dimension = points[0].length;\n    const centroids = makeMatrix(numCluster, dimension);\n    const counts = Array(numCluster).fill(0);\n\n    // Add points to centroids' accumulators and count points per centroid.\n    const numPoints = points.length;\n    for (let i = 0; i < numPoints; i++) {\n        const point = points[i];\n        const label = labels[i];\n        const current = centroids[label];\n        for (let j = 0; j < dimension; j++) {\n            current[j] += point[j];\n        }\n        counts[label] += 1;\n    }\n\n    // Rescale centroids, checking for any that have no points.\n    for (let i = 0; i < numCluster; i++) {\n        if (counts[i] === 0) {\n            throw new Error(`Centroid ${i} has no friends`);\n        }\n        const centroid = centroids[i];\n        for (let j = 0; j < dimension; j++) {\n            centroid[j] /= counts[i];\n        }\n    }\n\n    return centroids;\n}\n\n/**\n * Calculate the difference between old centroids and new centroids.\n *\n * @private\n * @param {Array<Array<number>>} left One list of centroids.\n * @param {Array<Array<number>>} right Another list of centroids.\n * @return {number} Distance between centroids.\n */\nfunction calculateChange(left, right) {\n    let total = 0;\n    for (let i = 0; i < left.length; i++) {\n        total += euclideanDistance(left[i], right[i]);\n    }\n    return total;\n}\n\nexport default kMeansCluster;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}