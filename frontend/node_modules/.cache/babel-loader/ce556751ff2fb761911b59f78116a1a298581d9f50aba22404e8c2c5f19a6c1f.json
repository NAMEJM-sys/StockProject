{"ast":null,"code":"/**\n * The [mode](https://en.wikipedia.org/wiki/Mode_%28statistics%29) is the number\n * that appears in a list the highest number of times.\n * There can be multiple modes in a list: in the event of a tie, this\n * algorithm will return the most recently seen mode.\n *\n * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):\n * a method of finding a typical or central value of a set of numbers.\n *\n * This runs in `O(n)` because the input is sorted.\n *\n * @param {Array<number>} sorted a sample of one or more data points\n * @returns {number} mode\n * @throws {Error} if sorted is empty\n * @example\n * modeSorted([0, 0, 1]); // => 0\n */\nfunction modeSorted(sorted) {\n  // Handle edge cases:\n  // The mode of an empty list is undefined\n  if (sorted.length === 0) {\n    throw new Error(\"mode requires at least one data point\");\n  }\n  if (sorted.length === 1) {\n    return sorted[0];\n  }\n\n  // This assumes it is dealing with an array of size > 1, since size\n  // 0 and 1 are handled immediately. Hence it starts at index 1 in the\n  // array.\n  let last = sorted[0];\n  // store the mode as we find new modes\n  let value = Number.NaN;\n  // store how many times we've seen the mode\n  let maxSeen = 0;\n  // how many times the current candidate for the mode\n  // has been seen\n  let seenThis = 1;\n\n  // end at sorted.length + 1 to fix the case in which the mode is\n  // the highest number that occurs in the sequence. the last iteration\n  // compares sorted[i], which is undefined, to the highest number\n  // in the series\n  for (let i = 1; i < sorted.length + 1; i++) {\n    // we're seeing a new number pass by\n    if (sorted[i] !== last) {\n      // the last number is the new mode since we saw it more\n      // often than the old one\n      if (seenThis > maxSeen) {\n        maxSeen = seenThis;\n        value = last;\n      }\n      seenThis = 1;\n      last = sorted[i];\n      // if this isn't a new number, it's one more occurrence of\n      // the potential mode\n    } else {\n      seenThis++;\n    }\n  }\n  return value;\n}\nexport default modeSorted;","map":{"version":3,"names":["modeSorted","sorted","length","Error","last","value","Number","NaN","maxSeen","seenThis","i"],"sources":["C:/ProPython/Stock2/node_modules/simple-statistics/src/mode_sorted.js"],"sourcesContent":["/**\n * The [mode](https://en.wikipedia.org/wiki/Mode_%28statistics%29) is the number\n * that appears in a list the highest number of times.\n * There can be multiple modes in a list: in the event of a tie, this\n * algorithm will return the most recently seen mode.\n *\n * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):\n * a method of finding a typical or central value of a set of numbers.\n *\n * This runs in `O(n)` because the input is sorted.\n *\n * @param {Array<number>} sorted a sample of one or more data points\n * @returns {number} mode\n * @throws {Error} if sorted is empty\n * @example\n * modeSorted([0, 0, 1]); // => 0\n */\nfunction modeSorted(sorted) {\n    // Handle edge cases:\n    // The mode of an empty list is undefined\n    if (sorted.length === 0) {\n        throw new Error(\"mode requires at least one data point\");\n    }\n    if (sorted.length === 1) {\n        return sorted[0];\n    }\n\n    // This assumes it is dealing with an array of size > 1, since size\n    // 0 and 1 are handled immediately. Hence it starts at index 1 in the\n    // array.\n    let last = sorted[0];\n    // store the mode as we find new modes\n    let value = Number.NaN;\n    // store how many times we've seen the mode\n    let maxSeen = 0;\n    // how many times the current candidate for the mode\n    // has been seen\n    let seenThis = 1;\n\n    // end at sorted.length + 1 to fix the case in which the mode is\n    // the highest number that occurs in the sequence. the last iteration\n    // compares sorted[i], which is undefined, to the highest number\n    // in the series\n    for (let i = 1; i < sorted.length + 1; i++) {\n        // we're seeing a new number pass by\n        if (sorted[i] !== last) {\n            // the last number is the new mode since we saw it more\n            // often than the old one\n            if (seenThis > maxSeen) {\n                maxSeen = seenThis;\n                value = last;\n            }\n            seenThis = 1;\n            last = sorted[i];\n            // if this isn't a new number, it's one more occurrence of\n            // the potential mode\n        } else {\n            seenThis++;\n        }\n    }\n    return value;\n}\n\nexport default modeSorted;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,UAAUA,CAACC,MAAM,EAAE;EACxB;EACA;EACA,IAAIA,MAAM,CAACC,MAAM,KAAK,CAAC,EAAE;IACrB,MAAM,IAAIC,KAAK,CAAC,uCAAuC,CAAC;EAC5D;EACA,IAAIF,MAAM,CAACC,MAAM,KAAK,CAAC,EAAE;IACrB,OAAOD,MAAM,CAAC,CAAC,CAAC;EACpB;;EAEA;EACA;EACA;EACA,IAAIG,IAAI,GAAGH,MAAM,CAAC,CAAC,CAAC;EACpB;EACA,IAAII,KAAK,GAAGC,MAAM,CAACC,GAAG;EACtB;EACA,IAAIC,OAAO,GAAG,CAAC;EACf;EACA;EACA,IAAIC,QAAQ,GAAG,CAAC;;EAEhB;EACA;EACA;EACA;EACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,MAAM,CAACC,MAAM,GAAG,CAAC,EAAEQ,CAAC,EAAE,EAAE;IACxC;IACA,IAAIT,MAAM,CAACS,CAAC,CAAC,KAAKN,IAAI,EAAE;MACpB;MACA;MACA,IAAIK,QAAQ,GAAGD,OAAO,EAAE;QACpBA,OAAO,GAAGC,QAAQ;QAClBJ,KAAK,GAAGD,IAAI;MAChB;MACAK,QAAQ,GAAG,CAAC;MACZL,IAAI,GAAGH,MAAM,CAACS,CAAC,CAAC;MAChB;MACA;IACJ,CAAC,MAAM;MACHD,QAAQ,EAAE;IACd;EACJ;EACA,OAAOJ,KAAK;AAChB;AAEA,eAAeL,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}