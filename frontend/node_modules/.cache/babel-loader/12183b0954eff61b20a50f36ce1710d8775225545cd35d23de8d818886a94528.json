{"ast":null,"code":"import sign from \"./sign.js\";\n\n/**\n * [Bisection method](https://en.wikipedia.org/wiki/Bisection_method) is a root-finding\n * method that repeatedly bisects an interval to find the root.\n *\n * This function returns a numerical approximation to the exact value.\n *\n * @param {Function} func input function\n * @param {number} start - start of interval\n * @param {number} end - end of interval\n * @param {number} maxIterations - the maximum number of iterations\n * @param {number} errorTolerance - the error tolerance\n * @returns {number} estimated root value\n * @throws {TypeError} Argument func must be a function\n *\n * @example\n * bisect(Math.cos,0,4,100,0.003); // => 1.572265625\n */\nfunction bisect(func, start, end, maxIterations, errorTolerance) {\n  if (typeof func !== \"function\") throw new TypeError(\"func must be a function\");\n  for (let i = 0; i < maxIterations; i++) {\n    const output = (start + end) / 2;\n    if (func(output) === 0 || Math.abs((end - start) / 2) < errorTolerance) {\n      return output;\n    }\n    if (sign(func(output)) === sign(func(start))) {\n      start = output;\n    } else {\n      end = output;\n    }\n  }\n  throw new Error(\"maximum number of iterations exceeded\");\n}\nexport default bisect;","map":{"version":3,"names":["sign","bisect","func","start","end","maxIterations","errorTolerance","TypeError","i","output","Math","abs","Error"],"sources":["C:/ProPython/Stock2/node_modules/simple-statistics/src/bisect.js"],"sourcesContent":["import sign from \"./sign.js\";\n\n/**\n * [Bisection method](https://en.wikipedia.org/wiki/Bisection_method) is a root-finding\n * method that repeatedly bisects an interval to find the root.\n *\n * This function returns a numerical approximation to the exact value.\n *\n * @param {Function} func input function\n * @param {number} start - start of interval\n * @param {number} end - end of interval\n * @param {number} maxIterations - the maximum number of iterations\n * @param {number} errorTolerance - the error tolerance\n * @returns {number} estimated root value\n * @throws {TypeError} Argument func must be a function\n *\n * @example\n * bisect(Math.cos,0,4,100,0.003); // => 1.572265625\n */\nfunction bisect(func, start, end, maxIterations, errorTolerance) {\n    if (typeof func !== \"function\")\n        throw new TypeError(\"func must be a function\");\n\n    for (let i = 0; i < maxIterations; i++) {\n        const output = (start + end) / 2;\n\n        if (\n            func(output) === 0 ||\n            Math.abs((end - start) / 2) < errorTolerance\n        ) {\n            return output;\n        }\n\n        if (sign(func(output)) === sign(func(start))) {\n            start = output;\n        } else {\n            end = output;\n        }\n    }\n\n    throw new Error(\"maximum number of iterations exceeded\");\n}\n\nexport default bisect;\n"],"mappings":"AAAA,OAAOA,IAAI,MAAM,WAAW;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,MAAMA,CAACC,IAAI,EAAEC,KAAK,EAAEC,GAAG,EAAEC,aAAa,EAAEC,cAAc,EAAE;EAC7D,IAAI,OAAOJ,IAAI,KAAK,UAAU,EAC1B,MAAM,IAAIK,SAAS,CAAC,yBAAyB,CAAC;EAElD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,aAAa,EAAEG,CAAC,EAAE,EAAE;IACpC,MAAMC,MAAM,GAAG,CAACN,KAAK,GAAGC,GAAG,IAAI,CAAC;IAEhC,IACIF,IAAI,CAACO,MAAM,CAAC,KAAK,CAAC,IAClBC,IAAI,CAACC,GAAG,CAAC,CAACP,GAAG,GAAGD,KAAK,IAAI,CAAC,CAAC,GAAGG,cAAc,EAC9C;MACE,OAAOG,MAAM;IACjB;IAEA,IAAIT,IAAI,CAACE,IAAI,CAACO,MAAM,CAAC,CAAC,KAAKT,IAAI,CAACE,IAAI,CAACC,KAAK,CAAC,CAAC,EAAE;MAC1CA,KAAK,GAAGM,MAAM;IAClB,CAAC,MAAM;MACHL,GAAG,GAAGK,MAAM;IAChB;EACJ;EAEA,MAAM,IAAIG,KAAK,CAAC,uCAAuC,CAAC;AAC5D;AAEA,eAAeX,MAAM","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}