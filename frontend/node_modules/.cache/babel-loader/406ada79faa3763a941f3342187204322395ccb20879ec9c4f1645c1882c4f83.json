{"ast":null,"code":"import quantileSorted from \"./quantile_sorted.js\";\nimport quickselect from \"./quickselect.js\";\n\n/**\n * The [quantile](https://en.wikipedia.org/wiki/Quantile):\n * this is a population quantile, since we assume to know the entire\n * dataset in this library. This is an implementation of the\n * [Quantiles of a Population](http://en.wikipedia.org/wiki/Quantile#Quantiles_of_a_population)\n * algorithm from wikipedia.\n *\n * Sample is a one-dimensional array of numbers,\n * and p is either a decimal number from 0 to 1 or an array of decimal\n * numbers from 0 to 1.\n * In terms of a k/q quantile, p = k/q - it's just dealing with fractions or dealing\n * with decimal values.\n * When p is an array, the result of the function is also an array containing the appropriate\n * quantiles in input order\n *\n * @param {Array<number>} x sample of one or more numbers\n * @param {Array<number> | number} p the desired quantile, as a number between 0 and 1\n * @returns {number} quantile\n * @example\n * quantile([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9\n */\nfunction quantile(x, p) {\n  const copy = x.slice();\n  if (Array.isArray(p)) {\n    // rearrange elements so that each element corresponding to a requested\n    // quantile is on a place it would be if the array was fully sorted\n    multiQuantileSelect(copy, p);\n    // Initialize the result array\n    const results = [];\n    // For each requested quantile\n    for (let i = 0; i < p.length; i++) {\n      results[i] = quantileSorted(copy, p[i]);\n    }\n    return results;\n  } else {\n    const idx = quantileIndex(copy.length, p);\n    quantileSelect(copy, idx, 0, copy.length - 1);\n    return quantileSorted(copy, p);\n  }\n}\nfunction quantileSelect(arr, k, left, right) {\n  if (k % 1 === 0) {\n    quickselect(arr, k, left, right);\n  } else {\n    k = Math.floor(k);\n    quickselect(arr, k, left, right);\n    quickselect(arr, k + 1, k + 1, right);\n  }\n}\nfunction multiQuantileSelect(arr, p) {\n  const indices = [0];\n  for (let i = 0; i < p.length; i++) {\n    indices.push(quantileIndex(arr.length, p[i]));\n  }\n  indices.push(arr.length - 1);\n  indices.sort(compare);\n  const stack = [0, indices.length - 1];\n  while (stack.length) {\n    const r = Math.ceil(stack.pop());\n    const l = Math.floor(stack.pop());\n    if (r - l <= 1) continue;\n    const m = Math.floor((l + r) / 2);\n    quantileSelect(arr, indices[m], Math.floor(indices[l]), Math.ceil(indices[r]));\n    stack.push(l, m, m, r);\n  }\n}\nfunction compare(a, b) {\n  return a - b;\n}\nfunction quantileIndex(len, p) {\n  const idx = len * p;\n  if (p === 1) {\n    // If p is 1, directly return the last index\n    return len - 1;\n  } else if (p === 0) {\n    // If p is 0, directly return the first index\n    return 0;\n  } else if (idx % 1 !== 0) {\n    // If index is not integer, return the next index in array\n    return Math.ceil(idx) - 1;\n  } else if (len % 2 === 0) {\n    // If the list has even-length, we'll return the middle of two indices\n    // around quantile to indicate that we need an average value of the two\n    return idx - 0.5;\n  } else {\n    // Finally, in the simple case of an integer index\n    // with an odd-length list, return the index\n    return idx;\n  }\n}\nexport default quantile;","map":{"version":3,"names":["quantileSorted","quickselect","quantile","x","p","copy","slice","Array","isArray","multiQuantileSelect","results","i","length","idx","quantileIndex","quantileSelect","arr","k","left","right","Math","floor","indices","push","sort","compare","stack","r","ceil","pop","l","m","a","b","len"],"sources":["C:/ProPython/Stock2/node_modules/simple-statistics/src/quantile.js"],"sourcesContent":["import quantileSorted from \"./quantile_sorted.js\";\nimport quickselect from \"./quickselect.js\";\n\n/**\n * The [quantile](https://en.wikipedia.org/wiki/Quantile):\n * this is a population quantile, since we assume to know the entire\n * dataset in this library. This is an implementation of the\n * [Quantiles of a Population](http://en.wikipedia.org/wiki/Quantile#Quantiles_of_a_population)\n * algorithm from wikipedia.\n *\n * Sample is a one-dimensional array of numbers,\n * and p is either a decimal number from 0 to 1 or an array of decimal\n * numbers from 0 to 1.\n * In terms of a k/q quantile, p = k/q - it's just dealing with fractions or dealing\n * with decimal values.\n * When p is an array, the result of the function is also an array containing the appropriate\n * quantiles in input order\n *\n * @param {Array<number>} x sample of one or more numbers\n * @param {Array<number> | number} p the desired quantile, as a number between 0 and 1\n * @returns {number} quantile\n * @example\n * quantile([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9\n */\nfunction quantile(x, p) {\n    const copy = x.slice();\n\n    if (Array.isArray(p)) {\n        // rearrange elements so that each element corresponding to a requested\n        // quantile is on a place it would be if the array was fully sorted\n        multiQuantileSelect(copy, p);\n        // Initialize the result array\n        const results = [];\n        // For each requested quantile\n        for (let i = 0; i < p.length; i++) {\n            results[i] = quantileSorted(copy, p[i]);\n        }\n        return results;\n    } else {\n        const idx = quantileIndex(copy.length, p);\n        quantileSelect(copy, idx, 0, copy.length - 1);\n        return quantileSorted(copy, p);\n    }\n}\n\nfunction quantileSelect(arr, k, left, right) {\n    if (k % 1 === 0) {\n        quickselect(arr, k, left, right);\n    } else {\n        k = Math.floor(k);\n        quickselect(arr, k, left, right);\n        quickselect(arr, k + 1, k + 1, right);\n    }\n}\n\nfunction multiQuantileSelect(arr, p) {\n    const indices = [0];\n    for (let i = 0; i < p.length; i++) {\n        indices.push(quantileIndex(arr.length, p[i]));\n    }\n    indices.push(arr.length - 1);\n    indices.sort(compare);\n\n    const stack = [0, indices.length - 1];\n\n    while (stack.length) {\n        const r = Math.ceil(stack.pop());\n        const l = Math.floor(stack.pop());\n        if (r - l <= 1) continue;\n\n        const m = Math.floor((l + r) / 2);\n        quantileSelect(\n            arr,\n            indices[m],\n            Math.floor(indices[l]),\n            Math.ceil(indices[r])\n        );\n\n        stack.push(l, m, m, r);\n    }\n}\n\nfunction compare(a, b) {\n    return a - b;\n}\n\nfunction quantileIndex(len, p) {\n    const idx = len * p;\n    if (p === 1) {\n        // If p is 1, directly return the last index\n        return len - 1;\n    } else if (p === 0) {\n        // If p is 0, directly return the first index\n        return 0;\n    } else if (idx % 1 !== 0) {\n        // If index is not integer, return the next index in array\n        return Math.ceil(idx) - 1;\n    } else if (len % 2 === 0) {\n        // If the list has even-length, we'll return the middle of two indices\n        // around quantile to indicate that we need an average value of the two\n        return idx - 0.5;\n    } else {\n        // Finally, in the simple case of an integer index\n        // with an odd-length list, return the index\n        return idx;\n    }\n}\n\nexport default quantile;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}