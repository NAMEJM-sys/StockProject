{"ast":null,"code":"/* eslint no-bitwise: 0 */\n\n/**\n * This function returns the quantile in which one would find the given value in\n * the given array. With a sorted array, leveraging binary search, we can find\n * this information in logarithmic time.\n *\n * @param {Array<number>} x input\n * @returns {number} value value\n * @example\n * quantileRankSorted([1, 2, 3, 4], 3); // => 0.75\n * quantileRankSorted([1, 2, 3, 3, 4], 3); // => 0.7\n * quantileRankSorted([1, 2, 3, 4], 6); // => 1\n * quantileRankSorted([1, 2, 3, 3, 5], 4); // => 0.8\n */\nfunction quantileRankSorted(x, value) {\n  // Value is lesser than any value in the array\n  if (value < x[0]) {\n    return 0;\n  }\n\n  // Value is greater than any value in the array\n  if (value > x[x.length - 1]) {\n    return 1;\n  }\n  let l = lowerBound(x, value);\n\n  // Value is not in the array\n  if (x[l] !== value) {\n    return l / x.length;\n  }\n  l++;\n  const u = upperBound(x, value);\n\n  // The value exists only once in the array\n  if (u === l) {\n    return l / x.length;\n  }\n\n  // Here, we are basically computing the mean of the range of indices\n  // containing our searched value. But, instead, of initializing an\n  // array and looping over it, there is a dedicated math formula that\n  // we apply below to get the result.\n  const r = u - l + 1;\n  const sum = r * (u + l) / 2;\n  const mean = sum / r;\n  return mean / x.length;\n}\nfunction lowerBound(x, value) {\n  let mid = 0;\n  let lo = 0;\n  let hi = x.length;\n  while (lo < hi) {\n    mid = lo + hi >>> 1;\n    if (value <= x[mid]) {\n      hi = mid;\n    } else {\n      lo = -~mid;\n    }\n  }\n  return lo;\n}\nfunction upperBound(x, value) {\n  let mid = 0;\n  let lo = 0;\n  let hi = x.length;\n  while (lo < hi) {\n    mid = lo + hi >>> 1;\n    if (value >= x[mid]) {\n      lo = -~mid;\n    } else {\n      hi = mid;\n    }\n  }\n  return lo;\n}\nexport default quantileRankSorted;","map":{"version":3,"names":["quantileRankSorted","x","value","length","l","lowerBound","u","upperBound","r","sum","mean","mid","lo","hi"],"sources":["C:/ProPython/Stock2/node_modules/simple-statistics/src/quantile_rank_sorted.js"],"sourcesContent":["/* eslint no-bitwise: 0 */\n\n/**\n * This function returns the quantile in which one would find the given value in\n * the given array. With a sorted array, leveraging binary search, we can find\n * this information in logarithmic time.\n *\n * @param {Array<number>} x input\n * @returns {number} value value\n * @example\n * quantileRankSorted([1, 2, 3, 4], 3); // => 0.75\n * quantileRankSorted([1, 2, 3, 3, 4], 3); // => 0.7\n * quantileRankSorted([1, 2, 3, 4], 6); // => 1\n * quantileRankSorted([1, 2, 3, 3, 5], 4); // => 0.8\n */\nfunction quantileRankSorted(x, value) {\n    // Value is lesser than any value in the array\n    if (value < x[0]) {\n        return 0;\n    }\n\n    // Value is greater than any value in the array\n    if (value > x[x.length - 1]) {\n        return 1;\n    }\n\n    let l = lowerBound(x, value);\n\n    // Value is not in the array\n    if (x[l] !== value) {\n        return l / x.length;\n    }\n\n    l++;\n\n    const u = upperBound(x, value);\n\n    // The value exists only once in the array\n    if (u === l) {\n        return l / x.length;\n    }\n\n    // Here, we are basically computing the mean of the range of indices\n    // containing our searched value. But, instead, of initializing an\n    // array and looping over it, there is a dedicated math formula that\n    // we apply below to get the result.\n    const r = u - l + 1;\n    const sum = (r * (u + l)) / 2;\n    const mean = sum / r;\n\n    return mean / x.length;\n}\n\nfunction lowerBound(x, value) {\n    let mid = 0;\n    let lo = 0;\n    let hi = x.length;\n\n    while (lo < hi) {\n        mid = (lo + hi) >>> 1;\n\n        if (value <= x[mid]) {\n            hi = mid;\n        } else {\n            lo = -~mid;\n        }\n    }\n\n    return lo;\n}\n\nfunction upperBound(x, value) {\n    let mid = 0;\n    let lo = 0;\n    let hi = x.length;\n\n    while (lo < hi) {\n        mid = (lo + hi) >>> 1;\n\n        if (value >= x[mid]) {\n            lo = -~mid;\n        } else {\n            hi = mid;\n        }\n    }\n\n    return lo;\n}\n\nexport default quantileRankSorted;\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,kBAAkBA,CAACC,CAAC,EAAEC,KAAK,EAAE;EAClC;EACA,IAAIA,KAAK,GAAGD,CAAC,CAAC,CAAC,CAAC,EAAE;IACd,OAAO,CAAC;EACZ;;EAEA;EACA,IAAIC,KAAK,GAAGD,CAAC,CAACA,CAAC,CAACE,MAAM,GAAG,CAAC,CAAC,EAAE;IACzB,OAAO,CAAC;EACZ;EAEA,IAAIC,CAAC,GAAGC,UAAU,CAACJ,CAAC,EAAEC,KAAK,CAAC;;EAE5B;EACA,IAAID,CAAC,CAACG,CAAC,CAAC,KAAKF,KAAK,EAAE;IAChB,OAAOE,CAAC,GAAGH,CAAC,CAACE,MAAM;EACvB;EAEAC,CAAC,EAAE;EAEH,MAAME,CAAC,GAAGC,UAAU,CAACN,CAAC,EAAEC,KAAK,CAAC;;EAE9B;EACA,IAAII,CAAC,KAAKF,CAAC,EAAE;IACT,OAAOA,CAAC,GAAGH,CAAC,CAACE,MAAM;EACvB;;EAEA;EACA;EACA;EACA;EACA,MAAMK,CAAC,GAAGF,CAAC,GAAGF,CAAC,GAAG,CAAC;EACnB,MAAMK,GAAG,GAAID,CAAC,IAAIF,CAAC,GAAGF,CAAC,CAAC,GAAI,CAAC;EAC7B,MAAMM,IAAI,GAAGD,GAAG,GAAGD,CAAC;EAEpB,OAAOE,IAAI,GAAGT,CAAC,CAACE,MAAM;AAC1B;AAEA,SAASE,UAAUA,CAACJ,CAAC,EAAEC,KAAK,EAAE;EAC1B,IAAIS,GAAG,GAAG,CAAC;EACX,IAAIC,EAAE,GAAG,CAAC;EACV,IAAIC,EAAE,GAAGZ,CAAC,CAACE,MAAM;EAEjB,OAAOS,EAAE,GAAGC,EAAE,EAAE;IACZF,GAAG,GAAIC,EAAE,GAAGC,EAAE,KAAM,CAAC;IAErB,IAAIX,KAAK,IAAID,CAAC,CAACU,GAAG,CAAC,EAAE;MACjBE,EAAE,GAAGF,GAAG;IACZ,CAAC,MAAM;MACHC,EAAE,GAAG,CAAC,CAACD,GAAG;IACd;EACJ;EAEA,OAAOC,EAAE;AACb;AAEA,SAASL,UAAUA,CAACN,CAAC,EAAEC,KAAK,EAAE;EAC1B,IAAIS,GAAG,GAAG,CAAC;EACX,IAAIC,EAAE,GAAG,CAAC;EACV,IAAIC,EAAE,GAAGZ,CAAC,CAACE,MAAM;EAEjB,OAAOS,EAAE,GAAGC,EAAE,EAAE;IACZF,GAAG,GAAIC,EAAE,GAAGC,EAAE,KAAM,CAAC;IAErB,IAAIX,KAAK,IAAID,CAAC,CAACU,GAAG,CAAC,EAAE;MACjBC,EAAE,GAAG,CAAC,CAACD,GAAG;IACd,CAAC,MAAM;MACHE,EAAE,GAAGF,GAAG;IACZ;EACJ;EAEA,OAAOC,EAAE;AACb;AAEA,eAAeZ,kBAAkB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}