{"ast":null,"code":"import makeMatrix from \"./make_matrix.js\";\nimport numericSort from \"./numeric_sort.js\";\nimport uniqueCountSorted from \"./unique_count_sorted.js\";\n\n/**\n * Generates incrementally computed values based on the sums and sums of\n * squares for the data array\n *\n * @private\n * @param {number} j\n * @param {number} i\n * @param {Array<number>} sums\n * @param {Array<number>} sumsOfSquares\n * @return {number}\n * @example\n * ssq(0, 1, [-1, 0, 2], [1, 1, 5]);\n */\nfunction ssq(j, i, sums, sumsOfSquares) {\n  let sji; // s(j, i)\n  if (j > 0) {\n    const muji = (sums[i] - sums[j - 1]) / (i - j + 1); // mu(j, i)\n    sji = sumsOfSquares[i] - sumsOfSquares[j - 1] - (i - j + 1) * muji * muji;\n  } else {\n    sji = sumsOfSquares[i] - sums[i] * sums[i] / (i + 1);\n  }\n  if (sji < 0) {\n    return 0;\n  }\n  return sji;\n}\n\n/**\n * Function that recursively divides and conquers computations\n * for cluster j\n *\n * @private\n * @param {number} iMin Minimum index in cluster to be computed\n * @param {number} iMax Maximum index in cluster to be computed\n * @param {number} cluster Index of the cluster currently being computed\n * @param {Array<Array<number>>} matrix\n * @param {Array<Array<number>>} backtrackMatrix\n * @param {Array<number>} sums\n * @param {Array<number>} sumsOfSquares\n */\nfunction fillMatrixColumn(iMin, iMax, cluster, matrix, backtrackMatrix, sums, sumsOfSquares) {\n  if (iMin > iMax) {\n    return;\n  }\n\n  // Start at midpoint between iMin and iMax\n  const i = Math.floor((iMin + iMax) / 2);\n  matrix[cluster][i] = matrix[cluster - 1][i - 1];\n  backtrackMatrix[cluster][i] = i;\n  let jlow = cluster; // the lower end for j\n\n  if (iMin > cluster) {\n    jlow = Math.max(jlow, backtrackMatrix[cluster][iMin - 1] || 0);\n  }\n  jlow = Math.max(jlow, backtrackMatrix[cluster - 1][i] || 0);\n  let jhigh = i - 1; // the upper end for j\n  if (iMax < matrix[0].length - 1) {\n    /* c8 ignore start */\n    jhigh = Math.min(jhigh, backtrackMatrix[cluster][iMax + 1] || 0);\n    /* c8 ignore end */\n  }\n  let sji;\n  let sjlowi;\n  let ssqjlow;\n  let ssqj;\n  for (let j = jhigh; j >= jlow; --j) {\n    sji = ssq(j, i, sums, sumsOfSquares);\n    if (sji + matrix[cluster - 1][jlow - 1] >= matrix[cluster][i]) {\n      break;\n    }\n\n    // Examine the lower bound of the cluster border\n    sjlowi = ssq(jlow, i, sums, sumsOfSquares);\n    ssqjlow = sjlowi + matrix[cluster - 1][jlow - 1];\n    if (ssqjlow < matrix[cluster][i]) {\n      // Shrink the lower bound\n      matrix[cluster][i] = ssqjlow;\n      backtrackMatrix[cluster][i] = jlow;\n    }\n    jlow++;\n    ssqj = sji + matrix[cluster - 1][j - 1];\n    if (ssqj < matrix[cluster][i]) {\n      matrix[cluster][i] = ssqj;\n      backtrackMatrix[cluster][i] = j;\n    }\n  }\n  fillMatrixColumn(iMin, i - 1, cluster, matrix, backtrackMatrix, sums, sumsOfSquares);\n  fillMatrixColumn(i + 1, iMax, cluster, matrix, backtrackMatrix, sums, sumsOfSquares);\n}\n\n/**\n * Initializes the main matrices used in Ckmeans and kicks\n * off the divide and conquer cluster computation strategy\n *\n * @private\n * @param {Array<number>} data sorted array of values\n * @param {Array<Array<number>>} matrix\n * @param {Array<Array<number>>} backtrackMatrix\n */\nfunction fillMatrices(data, matrix, backtrackMatrix) {\n  const nValues = matrix[0].length;\n\n  // Shift values by the median to improve numeric stability\n  const shift = data[Math.floor(nValues / 2)];\n\n  // Cumulative sum and cumulative sum of squares for all values in data array\n  const sums = [];\n  const sumsOfSquares = [];\n\n  // Initialize first column in matrix & backtrackMatrix\n  for (let i = 0, shiftedValue; i < nValues; ++i) {\n    shiftedValue = data[i] - shift;\n    if (i === 0) {\n      sums.push(shiftedValue);\n      sumsOfSquares.push(shiftedValue * shiftedValue);\n    } else {\n      sums.push(sums[i - 1] + shiftedValue);\n      sumsOfSquares.push(sumsOfSquares[i - 1] + shiftedValue * shiftedValue);\n    }\n\n    // Initialize for cluster = 0\n    matrix[0][i] = ssq(0, i, sums, sumsOfSquares);\n    backtrackMatrix[0][i] = 0;\n  }\n\n  // Initialize the rest of the columns\n  let iMin;\n  for (let cluster = 1; cluster < matrix.length; ++cluster) {\n    if (cluster < matrix.length - 1) {\n      iMin = cluster;\n    } else {\n      // No need to compute matrix[K-1][0] ... matrix[K-1][N-2]\n      iMin = nValues - 1;\n    }\n    fillMatrixColumn(iMin, nValues - 1, cluster, matrix, backtrackMatrix, sums, sumsOfSquares);\n  }\n}\n\n/**\n * Ckmeans clustering is an improvement on heuristic-based clustering\n * approaches like Jenks. The algorithm was developed in\n * [Haizhou Wang and Mingzhou Song](http://journal.r-project.org/archive/2011-2/RJournal_2011-2_Wang+Song.pdf)\n * as a [dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming) approach\n * to the problem of clustering numeric data into groups with the least\n * within-group sum-of-squared-deviations.\n *\n * Minimizing the difference within groups - what Wang & Song refer to as\n * `withinss`, or within sum-of-squares, means that groups are optimally\n * homogenous within and the data is split into representative groups.\n * This is very useful for visualization, where you may want to represent\n * a continuous variable in discrete color or style groups. This function\n * can provide groups that emphasize differences between data.\n *\n * Being a dynamic approach, this algorithm is based on two matrices that\n * store incrementally-computed values for squared deviations and backtracking\n * indexes.\n *\n * This implementation is based on Ckmeans 3.4.6, which introduced a new divide\n * and conquer approach that improved runtime from O(kn^2) to O(kn log(n)).\n *\n * Unlike the [original implementation](https://cran.r-project.org/web/packages/Ckmeans.1d.dp/index.html),\n * this implementation does not include any code to automatically determine\n * the optimal number of clusters: this information needs to be explicitly\n * provided.\n *\n * ### References\n * _Ckmeans.1d.dp: Optimal k-means Clustering in One Dimension by Dynamic\n * Programming_ Haizhou Wang and Mingzhou Song ISSN 2073-4859\n *\n * from The R Journal Vol. 3/2, December 2011\n * @param {Array<number>} x input data, as an array of number values\n * @param {number} nClusters number of desired classes. This cannot be\n * greater than the number of values in the data array.\n * @returns {Array<Array<number>>} clustered input\n * @throws {Error} if the number of requested clusters is higher than the size of the data\n * @example\n * ckmeans([-1, 2, -1, 2, 4, 5, 6, -1, 2, -1], 3);\n * // The input, clustered into groups of similar numbers.\n * //= [[-1, -1, -1, -1], [2, 2, 2], [4, 5, 6]]);\n */\nfunction ckmeans(x, nClusters) {\n  if (nClusters > x.length) {\n    throw new Error(\"cannot generate more classes than there are data values\");\n  }\n  const sorted = numericSort(x);\n  // we'll use this as the maximum number of clusters\n  const uniqueCount = uniqueCountSorted(sorted);\n\n  // if all of the input values are identical, there's one cluster\n  // with all of the input in it.\n  if (uniqueCount === 1) {\n    return [sorted];\n  }\n\n  // named 'S' originally\n  const matrix = makeMatrix(nClusters, sorted.length);\n  // named 'J' originally\n  const backtrackMatrix = makeMatrix(nClusters, sorted.length);\n\n  // This is a dynamic programming way to solve the problem of minimizing\n  // within-cluster sum of squares. It's similar to linear regression\n  // in this way, and this calculation incrementally computes the\n  // sum of squares that are later read.\n  fillMatrices(sorted, matrix, backtrackMatrix);\n\n  // The real work of Ckmeans clustering happens in the matrix generation:\n  // the generated matrices encode all possible clustering combinations, and\n  // once they're generated we can solve for the best clustering groups\n  // very quickly.\n  const clusters = [];\n  let clusterRight = backtrackMatrix[0].length - 1;\n\n  // Backtrack the clusters from the dynamic programming matrix. This\n  // starts at the bottom-right corner of the matrix (if the top-left is 0, 0),\n  // and moves the cluster target with the loop.\n  for (let cluster = backtrackMatrix.length - 1; cluster >= 0; cluster--) {\n    const clusterLeft = backtrackMatrix[cluster][clusterRight];\n\n    // fill the cluster from the sorted input by taking a slice of the\n    // array. the backtrack matrix makes this easy - it stores the\n    // indexes where the cluster should start and end.\n    clusters[cluster] = sorted.slice(clusterLeft, clusterRight + 1);\n    if (cluster > 0) {\n      clusterRight = clusterLeft - 1;\n    }\n  }\n  return clusters;\n}\nexport default ckmeans;","map":{"version":3,"names":["makeMatrix","numericSort","uniqueCountSorted","ssq","j","i","sums","sumsOfSquares","sji","muji","fillMatrixColumn","iMin","iMax","cluster","matrix","backtrackMatrix","Math","floor","jlow","max","jhigh","length","min","sjlowi","ssqjlow","ssqj","fillMatrices","data","nValues","shift","shiftedValue","push","ckmeans","x","nClusters","Error","sorted","uniqueCount","clusters","clusterRight","clusterLeft","slice"],"sources":["C:/ProPython/Stock2/node_modules/simple-statistics/src/ckmeans.js"],"sourcesContent":["import makeMatrix from \"./make_matrix.js\";\nimport numericSort from \"./numeric_sort.js\";\nimport uniqueCountSorted from \"./unique_count_sorted.js\";\n\n/**\n * Generates incrementally computed values based on the sums and sums of\n * squares for the data array\n *\n * @private\n * @param {number} j\n * @param {number} i\n * @param {Array<number>} sums\n * @param {Array<number>} sumsOfSquares\n * @return {number}\n * @example\n * ssq(0, 1, [-1, 0, 2], [1, 1, 5]);\n */\nfunction ssq(j, i, sums, sumsOfSquares) {\n    let sji; // s(j, i)\n    if (j > 0) {\n        const muji = (sums[i] - sums[j - 1]) / (i - j + 1); // mu(j, i)\n        sji =\n            sumsOfSquares[i] - sumsOfSquares[j - 1] - (i - j + 1) * muji * muji;\n    } else {\n        sji = sumsOfSquares[i] - (sums[i] * sums[i]) / (i + 1);\n    }\n    if (sji < 0) {\n        return 0;\n    }\n    return sji;\n}\n\n/**\n * Function that recursively divides and conquers computations\n * for cluster j\n *\n * @private\n * @param {number} iMin Minimum index in cluster to be computed\n * @param {number} iMax Maximum index in cluster to be computed\n * @param {number} cluster Index of the cluster currently being computed\n * @param {Array<Array<number>>} matrix\n * @param {Array<Array<number>>} backtrackMatrix\n * @param {Array<number>} sums\n * @param {Array<number>} sumsOfSquares\n */\nfunction fillMatrixColumn(\n    iMin,\n    iMax,\n    cluster,\n    matrix,\n    backtrackMatrix,\n    sums,\n    sumsOfSquares\n) {\n    if (iMin > iMax) {\n        return;\n    }\n\n    // Start at midpoint between iMin and iMax\n    const i = Math.floor((iMin + iMax) / 2);\n\n    matrix[cluster][i] = matrix[cluster - 1][i - 1];\n    backtrackMatrix[cluster][i] = i;\n\n    let jlow = cluster; // the lower end for j\n\n    if (iMin > cluster) {\n        jlow = Math.max(jlow, backtrackMatrix[cluster][iMin - 1] || 0);\n    }\n    jlow = Math.max(jlow, backtrackMatrix[cluster - 1][i] || 0);\n\n    let jhigh = i - 1; // the upper end for j\n    if (iMax < matrix[0].length - 1) {\n        /* c8 ignore start */\n        jhigh = Math.min(jhigh, backtrackMatrix[cluster][iMax + 1] || 0);\n        /* c8 ignore end */\n    }\n\n    let sji;\n    let sjlowi;\n    let ssqjlow;\n    let ssqj;\n    for (let j = jhigh; j >= jlow; --j) {\n        sji = ssq(j, i, sums, sumsOfSquares);\n\n        if (sji + matrix[cluster - 1][jlow - 1] >= matrix[cluster][i]) {\n            break;\n        }\n\n        // Examine the lower bound of the cluster border\n        sjlowi = ssq(jlow, i, sums, sumsOfSquares);\n\n        ssqjlow = sjlowi + matrix[cluster - 1][jlow - 1];\n\n        if (ssqjlow < matrix[cluster][i]) {\n            // Shrink the lower bound\n            matrix[cluster][i] = ssqjlow;\n            backtrackMatrix[cluster][i] = jlow;\n        }\n        jlow++;\n\n        ssqj = sji + matrix[cluster - 1][j - 1];\n        if (ssqj < matrix[cluster][i]) {\n            matrix[cluster][i] = ssqj;\n            backtrackMatrix[cluster][i] = j;\n        }\n    }\n\n    fillMatrixColumn(\n        iMin,\n        i - 1,\n        cluster,\n        matrix,\n        backtrackMatrix,\n        sums,\n        sumsOfSquares\n    );\n    fillMatrixColumn(\n        i + 1,\n        iMax,\n        cluster,\n        matrix,\n        backtrackMatrix,\n        sums,\n        sumsOfSquares\n    );\n}\n\n/**\n * Initializes the main matrices used in Ckmeans and kicks\n * off the divide and conquer cluster computation strategy\n *\n * @private\n * @param {Array<number>} data sorted array of values\n * @param {Array<Array<number>>} matrix\n * @param {Array<Array<number>>} backtrackMatrix\n */\nfunction fillMatrices(data, matrix, backtrackMatrix) {\n    const nValues = matrix[0].length;\n\n    // Shift values by the median to improve numeric stability\n    const shift = data[Math.floor(nValues / 2)];\n\n    // Cumulative sum and cumulative sum of squares for all values in data array\n    const sums = [];\n    const sumsOfSquares = [];\n\n    // Initialize first column in matrix & backtrackMatrix\n    for (let i = 0, shiftedValue; i < nValues; ++i) {\n        shiftedValue = data[i] - shift;\n        if (i === 0) {\n            sums.push(shiftedValue);\n            sumsOfSquares.push(shiftedValue * shiftedValue);\n        } else {\n            sums.push(sums[i - 1] + shiftedValue);\n            sumsOfSquares.push(\n                sumsOfSquares[i - 1] + shiftedValue * shiftedValue\n            );\n        }\n\n        // Initialize for cluster = 0\n        matrix[0][i] = ssq(0, i, sums, sumsOfSquares);\n        backtrackMatrix[0][i] = 0;\n    }\n\n    // Initialize the rest of the columns\n    let iMin;\n    for (let cluster = 1; cluster < matrix.length; ++cluster) {\n        if (cluster < matrix.length - 1) {\n            iMin = cluster;\n        } else {\n            // No need to compute matrix[K-1][0] ... matrix[K-1][N-2]\n            iMin = nValues - 1;\n        }\n\n        fillMatrixColumn(\n            iMin,\n            nValues - 1,\n            cluster,\n            matrix,\n            backtrackMatrix,\n            sums,\n            sumsOfSquares\n        );\n    }\n}\n\n/**\n * Ckmeans clustering is an improvement on heuristic-based clustering\n * approaches like Jenks. The algorithm was developed in\n * [Haizhou Wang and Mingzhou Song](http://journal.r-project.org/archive/2011-2/RJournal_2011-2_Wang+Song.pdf)\n * as a [dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming) approach\n * to the problem of clustering numeric data into groups with the least\n * within-group sum-of-squared-deviations.\n *\n * Minimizing the difference within groups - what Wang & Song refer to as\n * `withinss`, or within sum-of-squares, means that groups are optimally\n * homogenous within and the data is split into representative groups.\n * This is very useful for visualization, where you may want to represent\n * a continuous variable in discrete color or style groups. This function\n * can provide groups that emphasize differences between data.\n *\n * Being a dynamic approach, this algorithm is based on two matrices that\n * store incrementally-computed values for squared deviations and backtracking\n * indexes.\n *\n * This implementation is based on Ckmeans 3.4.6, which introduced a new divide\n * and conquer approach that improved runtime from O(kn^2) to O(kn log(n)).\n *\n * Unlike the [original implementation](https://cran.r-project.org/web/packages/Ckmeans.1d.dp/index.html),\n * this implementation does not include any code to automatically determine\n * the optimal number of clusters: this information needs to be explicitly\n * provided.\n *\n * ### References\n * _Ckmeans.1d.dp: Optimal k-means Clustering in One Dimension by Dynamic\n * Programming_ Haizhou Wang and Mingzhou Song ISSN 2073-4859\n *\n * from The R Journal Vol. 3/2, December 2011\n * @param {Array<number>} x input data, as an array of number values\n * @param {number} nClusters number of desired classes. This cannot be\n * greater than the number of values in the data array.\n * @returns {Array<Array<number>>} clustered input\n * @throws {Error} if the number of requested clusters is higher than the size of the data\n * @example\n * ckmeans([-1, 2, -1, 2, 4, 5, 6, -1, 2, -1], 3);\n * // The input, clustered into groups of similar numbers.\n * //= [[-1, -1, -1, -1], [2, 2, 2], [4, 5, 6]]);\n */\nfunction ckmeans(x, nClusters) {\n    if (nClusters > x.length) {\n        throw new Error(\n            \"cannot generate more classes than there are data values\"\n        );\n    }\n\n    const sorted = numericSort(x);\n    // we'll use this as the maximum number of clusters\n    const uniqueCount = uniqueCountSorted(sorted);\n\n    // if all of the input values are identical, there's one cluster\n    // with all of the input in it.\n    if (uniqueCount === 1) {\n        return [sorted];\n    }\n\n    // named 'S' originally\n    const matrix = makeMatrix(nClusters, sorted.length);\n    // named 'J' originally\n    const backtrackMatrix = makeMatrix(nClusters, sorted.length);\n\n    // This is a dynamic programming way to solve the problem of minimizing\n    // within-cluster sum of squares. It's similar to linear regression\n    // in this way, and this calculation incrementally computes the\n    // sum of squares that are later read.\n    fillMatrices(sorted, matrix, backtrackMatrix);\n\n    // The real work of Ckmeans clustering happens in the matrix generation:\n    // the generated matrices encode all possible clustering combinations, and\n    // once they're generated we can solve for the best clustering groups\n    // very quickly.\n    const clusters = [];\n    let clusterRight = backtrackMatrix[0].length - 1;\n\n    // Backtrack the clusters from the dynamic programming matrix. This\n    // starts at the bottom-right corner of the matrix (if the top-left is 0, 0),\n    // and moves the cluster target with the loop.\n    for (let cluster = backtrackMatrix.length - 1; cluster >= 0; cluster--) {\n        const clusterLeft = backtrackMatrix[cluster][clusterRight];\n\n        // fill the cluster from the sorted input by taking a slice of the\n        // array. the backtrack matrix makes this easy - it stores the\n        // indexes where the cluster should start and end.\n        clusters[cluster] = sorted.slice(clusterLeft, clusterRight + 1);\n\n        if (cluster > 0) {\n            clusterRight = clusterLeft - 1;\n        }\n    }\n\n    return clusters;\n}\n\nexport default ckmeans;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}