{"ast":null,"code":"import euclideanDistance from \"./euclidean_distance.js\";\nimport makeMatrix from \"./make_matrix.js\";\nimport max from \"./max.js\";\n\n/**\n * Calculate the [silhouette values](https://en.wikipedia.org/wiki/Silhouette_(clustering))\n * for clustered data.\n *\n * @param {Array<Array<number>>} points N-dimensional coordinates of points.\n * @param {Array<number>} labels Labels of points. This must be the same length as `points`,\n * and values must lie in [0..G-1], where G is the number of groups.\n * @return {Array<number>} The silhouette value for each point.\n *\n * @example\n * silhouette([[0.25], [0.75]], [0, 0]); // => [1.0, 1.0]\n */\nfunction silhouette(points, labels) {\n  if (points.length !== labels.length) {\n    throw new Error(\"must have exactly as many labels as points\");\n  }\n  const groupings = createGroups(labels);\n  const distances = calculateAllDistances(points);\n  const result = [];\n  for (let i = 0; i < points.length; i++) {\n    let s = 0;\n    if (groupings[labels[i]].length > 1) {\n      const a = meanDistanceFromPointToGroup(i, groupings[labels[i]], distances);\n      const b = meanDistanceToNearestGroup(i, labels, groupings, distances);\n      s = (b - a) / Math.max(a, b);\n    }\n    result.push(s);\n  }\n  return result;\n}\n\n/**\n * Create a lookup table mapping group IDs to point IDs.\n *\n * @private\n * @param {Array<number>} labels Labels of points. This must be the same length as `points`,\n * and values must lie in [0..G-1], where G is the number of groups.\n * @return {Array<Array<number>>} An array of length G, each of whose entries is an array\n * containing the indices of the points in that group.\n */\nfunction createGroups(labels) {\n  const numGroups = 1 + max(labels);\n  const result = Array(numGroups);\n  for (let i = 0; i < labels.length; i++) {\n    const label = labels[i];\n    if (result[label] === undefined) {\n      result[label] = [];\n    }\n    result[label].push(i);\n  }\n  return result;\n}\n\n/**\n * Create a lookup table of all inter-point distances.\n *\n * @private\n * @param {Array<Array<number>>} points N-dimensional coordinates of points.\n * @return {Array<Array<number>>} A symmetric square array of inter-point distances\n * (zero on the diagonal).\n */\nfunction calculateAllDistances(points) {\n  const numPoints = points.length;\n  const result = makeMatrix(numPoints, numPoints);\n  for (let i = 0; i < numPoints; i++) {\n    for (let j = 0; j < i; j++) {\n      result[i][j] = euclideanDistance(points[i], points[j]);\n      result[j][i] = result[i][j];\n    }\n  }\n  return result;\n}\n\n/**\n * Calculate the mean distance between this point and all the points in the\n * nearest group (as determined by which point in another group is closest).\n *\n * @private\n * @param {number} which The index of this point.\n * @param {Array<number>} labels Labels of points.\n * @param {Array<Array<number>>} groupings An array whose entries are arrays\n * containing the indices of the points in that group.\n * @param {Array<Array<number>>} distances A symmetric square array of inter-point\n * distances.\n * @return {number} The mean distance from this point to others in the nearest\n * group.\n */\nfunction meanDistanceToNearestGroup(which, labels, groupings, distances) {\n  const label = labels[which];\n  let result = Number.MAX_VALUE;\n  for (let i = 0; i < groupings.length; i++) {\n    if (i !== label) {\n      const d = meanDistanceFromPointToGroup(which, groupings[i], distances);\n      if (d < result) {\n        result = d;\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Calculate the mean distance between a point and all the points in a group\n * (possibly its own).\n *\n * @private\n * @param {number} which The index of this point.\n * @param {Array<number>} group The indices of all the points in the group in\n * question.\n * @param {Array<Array<number>>} distances A symmetric square array of inter-point\n * distances.\n * @return {number} The mean distance from this point to others in the\n * specified group.\n */\nfunction meanDistanceFromPointToGroup(which, group, distances) {\n  let total = 0;\n  for (let i = 0; i < group.length; i++) {\n    total += distances[which][group[i]];\n  }\n  return total / group.length;\n}\nexport default silhouette;","map":{"version":3,"names":["euclideanDistance","makeMatrix","max","silhouette","points","labels","length","Error","groupings","createGroups","distances","calculateAllDistances","result","i","s","a","meanDistanceFromPointToGroup","b","meanDistanceToNearestGroup","Math","push","numGroups","Array","label","undefined","numPoints","j","which","Number","MAX_VALUE","d","group","total"],"sources":["C:/ProPython/Stock2/node_modules/simple-statistics/src/silhouette.js"],"sourcesContent":["import euclideanDistance from \"./euclidean_distance.js\";\nimport makeMatrix from \"./make_matrix.js\";\nimport max from \"./max.js\";\n\n/**\n * Calculate the [silhouette values](https://en.wikipedia.org/wiki/Silhouette_(clustering))\n * for clustered data.\n *\n * @param {Array<Array<number>>} points N-dimensional coordinates of points.\n * @param {Array<number>} labels Labels of points. This must be the same length as `points`,\n * and values must lie in [0..G-1], where G is the number of groups.\n * @return {Array<number>} The silhouette value for each point.\n *\n * @example\n * silhouette([[0.25], [0.75]], [0, 0]); // => [1.0, 1.0]\n */\nfunction silhouette(points, labels) {\n    if (points.length !== labels.length) {\n        throw new Error(\"must have exactly as many labels as points\");\n    }\n    const groupings = createGroups(labels);\n    const distances = calculateAllDistances(points);\n    const result = [];\n    for (let i = 0; i < points.length; i++) {\n        let s = 0;\n        if (groupings[labels[i]].length > 1) {\n            const a = meanDistanceFromPointToGroup(\n                i,\n                groupings[labels[i]],\n                distances\n            );\n            const b = meanDistanceToNearestGroup(\n                i,\n                labels,\n                groupings,\n                distances\n            );\n            s = (b - a) / Math.max(a, b);\n        }\n        result.push(s);\n    }\n    return result;\n}\n\n/**\n * Create a lookup table mapping group IDs to point IDs.\n *\n * @private\n * @param {Array<number>} labels Labels of points. This must be the same length as `points`,\n * and values must lie in [0..G-1], where G is the number of groups.\n * @return {Array<Array<number>>} An array of length G, each of whose entries is an array\n * containing the indices of the points in that group.\n */\nfunction createGroups(labels) {\n    const numGroups = 1 + max(labels);\n    const result = Array(numGroups);\n    for (let i = 0; i < labels.length; i++) {\n        const label = labels[i];\n        if (result[label] === undefined) {\n            result[label] = [];\n        }\n        result[label].push(i);\n    }\n    return result;\n}\n\n/**\n * Create a lookup table of all inter-point distances.\n *\n * @private\n * @param {Array<Array<number>>} points N-dimensional coordinates of points.\n * @return {Array<Array<number>>} A symmetric square array of inter-point distances\n * (zero on the diagonal).\n */\nfunction calculateAllDistances(points) {\n    const numPoints = points.length;\n    const result = makeMatrix(numPoints, numPoints);\n    for (let i = 0; i < numPoints; i++) {\n        for (let j = 0; j < i; j++) {\n            result[i][j] = euclideanDistance(points[i], points[j]);\n            result[j][i] = result[i][j];\n        }\n    }\n    return result;\n}\n\n/**\n * Calculate the mean distance between this point and all the points in the\n * nearest group (as determined by which point in another group is closest).\n *\n * @private\n * @param {number} which The index of this point.\n * @param {Array<number>} labels Labels of points.\n * @param {Array<Array<number>>} groupings An array whose entries are arrays\n * containing the indices of the points in that group.\n * @param {Array<Array<number>>} distances A symmetric square array of inter-point\n * distances.\n * @return {number} The mean distance from this point to others in the nearest\n * group.\n */\nfunction meanDistanceToNearestGroup(which, labels, groupings, distances) {\n    const label = labels[which];\n    let result = Number.MAX_VALUE;\n    for (let i = 0; i < groupings.length; i++) {\n        if (i !== label) {\n            const d = meanDistanceFromPointToGroup(\n                which,\n                groupings[i],\n                distances\n            );\n            if (d < result) {\n                result = d;\n            }\n        }\n    }\n    return result;\n}\n\n/**\n * Calculate the mean distance between a point and all the points in a group\n * (possibly its own).\n *\n * @private\n * @param {number} which The index of this point.\n * @param {Array<number>} group The indices of all the points in the group in\n * question.\n * @param {Array<Array<number>>} distances A symmetric square array of inter-point\n * distances.\n * @return {number} The mean distance from this point to others in the\n * specified group.\n */\nfunction meanDistanceFromPointToGroup(which, group, distances) {\n    let total = 0;\n    for (let i = 0; i < group.length; i++) {\n        total += distances[which][group[i]];\n    }\n    return total / group.length;\n}\n\nexport default silhouette;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}