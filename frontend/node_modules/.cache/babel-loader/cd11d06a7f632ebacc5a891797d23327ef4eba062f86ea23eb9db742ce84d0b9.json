{"ast":null,"code":"import max from \"./max.js\";\nimport min from \"./min.js\";\n\n/**\n * Given an array of x, this will find the extent of the\n * x and return an array of breaks that can be used\n * to categorize the x into a number of classes. The\n * returned array will always be 1 longer than the number of\n * classes because it includes the minimum value.\n *\n * @param {Array<number>} x an array of number values\n * @param {number} nClasses number of desired classes\n * @returns {Array<number>} array of class break positions\n * @example\n * equalIntervalBreaks([1, 2, 3, 4, 5, 6], 4); // => [1, 2.25, 3.5, 4.75, 6]\n */\nfunction equalIntervalBreaks(x, nClasses) {\n  if (x.length < 2) {\n    return x;\n  }\n  const theMin = min(x);\n  const theMax = max(x);\n\n  // the first break will always be the minimum value\n  // in the xset\n  const breaks = [theMin];\n\n  // The size of each break is the full range of the x\n  // divided by the number of classes requested\n  const breakSize = (theMax - theMin) / nClasses;\n\n  // In the case of nClasses = 1, this loop won't run\n  // and the returned breaks will be [min, max]\n  for (let i = 1; i < nClasses; i++) {\n    breaks.push(breaks[0] + breakSize * i);\n  }\n\n  // the last break will always be the\n  // maximum.\n  breaks.push(theMax);\n  return breaks;\n}\nexport default equalIntervalBreaks;","map":{"version":3,"names":["max","min","equalIntervalBreaks","x","nClasses","length","theMin","theMax","breaks","breakSize","i","push"],"sources":["C:/ProPython/Stock2/node_modules/simple-statistics/src/equal_interval_breaks.js"],"sourcesContent":["import max from \"./max.js\";\nimport min from \"./min.js\";\n\n/**\n * Given an array of x, this will find the extent of the\n * x and return an array of breaks that can be used\n * to categorize the x into a number of classes. The\n * returned array will always be 1 longer than the number of\n * classes because it includes the minimum value.\n *\n * @param {Array<number>} x an array of number values\n * @param {number} nClasses number of desired classes\n * @returns {Array<number>} array of class break positions\n * @example\n * equalIntervalBreaks([1, 2, 3, 4, 5, 6], 4); // => [1, 2.25, 3.5, 4.75, 6]\n */\nfunction equalIntervalBreaks(x, nClasses) {\n    if (x.length < 2) {\n        return x;\n    }\n\n    const theMin = min(x);\n    const theMax = max(x);\n\n    // the first break will always be the minimum value\n    // in the xset\n    const breaks = [theMin];\n\n    // The size of each break is the full range of the x\n    // divided by the number of classes requested\n    const breakSize = (theMax - theMin) / nClasses;\n\n    // In the case of nClasses = 1, this loop won't run\n    // and the returned breaks will be [min, max]\n    for (let i = 1; i < nClasses; i++) {\n        breaks.push(breaks[0] + breakSize * i);\n    }\n\n    // the last break will always be the\n    // maximum.\n    breaks.push(theMax);\n\n    return breaks;\n}\n\nexport default equalIntervalBreaks;\n"],"mappings":"AAAA,OAAOA,GAAG,MAAM,UAAU;AAC1B,OAAOC,GAAG,MAAM,UAAU;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,mBAAmBA,CAACC,CAAC,EAAEC,QAAQ,EAAE;EACtC,IAAID,CAAC,CAACE,MAAM,GAAG,CAAC,EAAE;IACd,OAAOF,CAAC;EACZ;EAEA,MAAMG,MAAM,GAAGL,GAAG,CAACE,CAAC,CAAC;EACrB,MAAMI,MAAM,GAAGP,GAAG,CAACG,CAAC,CAAC;;EAErB;EACA;EACA,MAAMK,MAAM,GAAG,CAACF,MAAM,CAAC;;EAEvB;EACA;EACA,MAAMG,SAAS,GAAG,CAACF,MAAM,GAAGD,MAAM,IAAIF,QAAQ;;EAE9C;EACA;EACA,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,QAAQ,EAAEM,CAAC,EAAE,EAAE;IAC/BF,MAAM,CAACG,IAAI,CAACH,MAAM,CAAC,CAAC,CAAC,GAAGC,SAAS,GAAGC,CAAC,CAAC;EAC1C;;EAEA;EACA;EACAF,MAAM,CAACG,IAAI,CAACJ,MAAM,CAAC;EAEnB,OAAOC,MAAM;AACjB;AAEA,eAAeN,mBAAmB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}