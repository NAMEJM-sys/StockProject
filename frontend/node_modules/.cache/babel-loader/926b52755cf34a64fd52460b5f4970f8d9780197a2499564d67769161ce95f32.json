{"ast":null,"code":"/**\n * Our default sum is the [Kahan-Babuska algorithm](https://pdfs.semanticscholar.org/1760/7d467cda1d0277ad272deb2113533131dc09.pdf).\n * This method is an improvement over the classical\n * [Kahan summation algorithm](https://en.wikipedia.org/wiki/Kahan_summation_algorithm).\n * It aims at computing the sum of a list of numbers while correcting for\n * floating-point errors. Traditionally, sums are calculated as many\n * successive additions, each one with its own floating-point roundoff. These\n * losses in precision add up as the number of numbers increases. This alternative\n * algorithm is more accurate than the simple way of calculating sums by simple\n * addition.\n *\n * This runs in `O(n)`, linear time, with respect to the length of the array.\n *\n * @param {Array<number>} x input\n * @return {number} sum of all input numbers\n * @example\n * sum([1, 2, 3]); // => 6\n */\nfunction sum(x) {\n  // If the array is empty, we needn't bother computing its sum\n  if (x.length === 0) {\n    return 0;\n  }\n\n  // Initializing the sum as the first number in the array\n  let sum = x[0];\n\n  // Keeping track of the floating-point error correction\n  let correction = 0;\n  let transition;\n  if (typeof sum !== \"number\") {\n    return Number.NaN;\n  }\n  for (let i = 1; i < x.length; i++) {\n    if (typeof x[i] !== \"number\") {\n      return Number.NaN;\n    }\n    transition = sum + x[i];\n\n    // Here we need to update the correction in a different fashion\n    // if the new absolute value is greater than the absolute sum\n    if (Math.abs(sum) >= Math.abs(x[i])) {\n      correction += sum - transition + x[i];\n    } else {\n      correction += x[i] - transition + sum;\n    }\n    sum = transition;\n  }\n\n  // Returning the corrected sum\n  return sum + correction;\n}\nexport default sum;","map":{"version":3,"names":["sum","x","length","correction","transition","Number","NaN","i","Math","abs"],"sources":["C:/ProPython/Stock2/node_modules/simple-statistics/src/sum.js"],"sourcesContent":["/**\n * Our default sum is the [Kahan-Babuska algorithm](https://pdfs.semanticscholar.org/1760/7d467cda1d0277ad272deb2113533131dc09.pdf).\n * This method is an improvement over the classical\n * [Kahan summation algorithm](https://en.wikipedia.org/wiki/Kahan_summation_algorithm).\n * It aims at computing the sum of a list of numbers while correcting for\n * floating-point errors. Traditionally, sums are calculated as many\n * successive additions, each one with its own floating-point roundoff. These\n * losses in precision add up as the number of numbers increases. This alternative\n * algorithm is more accurate than the simple way of calculating sums by simple\n * addition.\n *\n * This runs in `O(n)`, linear time, with respect to the length of the array.\n *\n * @param {Array<number>} x input\n * @return {number} sum of all input numbers\n * @example\n * sum([1, 2, 3]); // => 6\n */\nfunction sum(x) {\n    // If the array is empty, we needn't bother computing its sum\n    if (x.length === 0) {\n        return 0;\n    }\n\n    // Initializing the sum as the first number in the array\n    let sum = x[0];\n\n    // Keeping track of the floating-point error correction\n    let correction = 0;\n\n    let transition;\n\n    if (typeof sum !== \"number\") {\n        return Number.NaN;\n    }\n\n    for (let i = 1; i < x.length; i++) {\n        if (typeof x[i] !== \"number\") {\n            return Number.NaN;\n        }\n        transition = sum + x[i];\n\n        // Here we need to update the correction in a different fashion\n        // if the new absolute value is greater than the absolute sum\n        if (Math.abs(sum) >= Math.abs(x[i])) {\n            correction += sum - transition + x[i];\n        } else {\n            correction += x[i] - transition + sum;\n        }\n\n        sum = transition;\n    }\n\n    // Returning the corrected sum\n    return sum + correction;\n}\n\nexport default sum;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,GAAGA,CAACC,CAAC,EAAE;EACZ;EACA,IAAIA,CAAC,CAACC,MAAM,KAAK,CAAC,EAAE;IAChB,OAAO,CAAC;EACZ;;EAEA;EACA,IAAIF,GAAG,GAAGC,CAAC,CAAC,CAAC,CAAC;;EAEd;EACA,IAAIE,UAAU,GAAG,CAAC;EAElB,IAAIC,UAAU;EAEd,IAAI,OAAOJ,GAAG,KAAK,QAAQ,EAAE;IACzB,OAAOK,MAAM,CAACC,GAAG;EACrB;EAEA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,CAAC,CAACC,MAAM,EAAEK,CAAC,EAAE,EAAE;IAC/B,IAAI,OAAON,CAAC,CAACM,CAAC,CAAC,KAAK,QAAQ,EAAE;MAC1B,OAAOF,MAAM,CAACC,GAAG;IACrB;IACAF,UAAU,GAAGJ,GAAG,GAAGC,CAAC,CAACM,CAAC,CAAC;;IAEvB;IACA;IACA,IAAIC,IAAI,CAACC,GAAG,CAACT,GAAG,CAAC,IAAIQ,IAAI,CAACC,GAAG,CAACR,CAAC,CAACM,CAAC,CAAC,CAAC,EAAE;MACjCJ,UAAU,IAAIH,GAAG,GAAGI,UAAU,GAAGH,CAAC,CAACM,CAAC,CAAC;IACzC,CAAC,MAAM;MACHJ,UAAU,IAAIF,CAAC,CAACM,CAAC,CAAC,GAAGH,UAAU,GAAGJ,GAAG;IACzC;IAEAA,GAAG,GAAGI,UAAU;EACpB;;EAEA;EACA,OAAOJ,GAAG,GAAGG,UAAU;AAC3B;AAEA,eAAeH,GAAG","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}