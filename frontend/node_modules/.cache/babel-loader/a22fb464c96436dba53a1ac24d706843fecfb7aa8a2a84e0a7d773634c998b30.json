{"ast":null,"code":"/**\n * This function calculates the Wilcoxon rank sum statistic for the first sample\n * with respect to the second. The Wilcoxon rank sum test is a non-parametric\n * alternative to the t-test which is equivalent to the\n * [Mann-Whitney U test](https://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U_test).\n * The statistic is calculated by pooling all the observations together, ranking them,\n * and then summing the ranks associated with one of the samples. If this rank sum is\n * sufficiently large or small we reject the hypothesis that the two samples come\n * from the same distribution in favor of the alternative that one is shifted with\n * respect to the other.\n *\n * @param {Array<number>} sampleX a sample as an array of numbers\n * @param {Array<number>} sampleY a sample as an array of numbers\n * @returns {number} rank sum for sampleX\n *\n * @example\n * wilcoxonRankSum([1, 4, 8], [9, 12, 15]); // => 6\n */\nfunction wilcoxonRankSum(sampleX, sampleY) {\n  if (!sampleX.length || !sampleY.length) {\n    throw new Error(\"Neither sample can be empty\");\n  }\n  const pooledSamples = sampleX.map(x => ({\n    label: \"x\",\n    value: x\n  })).concat(sampleY.map(y => ({\n    label: \"y\",\n    value: y\n  }))).sort((a, b) => a.value - b.value);\n  for (let rank = 0; rank < pooledSamples.length; rank++) {\n    pooledSamples[rank].rank = rank;\n  }\n  let tiedRanks = [pooledSamples[0].rank];\n  for (let i = 1; i < pooledSamples.length; i++) {\n    if (pooledSamples[i].value === pooledSamples[i - 1].value) {\n      tiedRanks.push(pooledSamples[i].rank);\n      if (i === pooledSamples.length - 1) {\n        replaceRanksInPlace(pooledSamples, tiedRanks);\n      }\n    } else if (tiedRanks.length > 1) {\n      replaceRanksInPlace(pooledSamples, tiedRanks);\n    } else {\n      tiedRanks = [pooledSamples[i].rank];\n    }\n  }\n  function replaceRanksInPlace(pooledSamples, tiedRanks) {\n    const average = (tiedRanks[0] + tiedRanks[tiedRanks.length - 1]) / 2;\n    for (let i = 0; i < tiedRanks.length; i++) {\n      pooledSamples[tiedRanks[i]].rank = average;\n    }\n  }\n  let rankSum = 0;\n  for (let i = 0; i < pooledSamples.length; i++) {\n    const sample = pooledSamples[i];\n    if (sample.label === \"x\") {\n      rankSum += sample.rank + 1;\n    }\n  }\n  return rankSum;\n}\nexport default wilcoxonRankSum;","map":{"version":3,"names":["wilcoxonRankSum","sampleX","sampleY","length","Error","pooledSamples","map","x","label","value","concat","y","sort","a","b","rank","tiedRanks","i","push","replaceRanksInPlace","average","rankSum","sample"],"sources":["C:/ProPython/Stock2/node_modules/simple-statistics/src/wilcoxon_rank_sum.js"],"sourcesContent":["/**\n * This function calculates the Wilcoxon rank sum statistic for the first sample\n * with respect to the second. The Wilcoxon rank sum test is a non-parametric\n * alternative to the t-test which is equivalent to the\n * [Mann-Whitney U test](https://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U_test).\n * The statistic is calculated by pooling all the observations together, ranking them,\n * and then summing the ranks associated with one of the samples. If this rank sum is\n * sufficiently large or small we reject the hypothesis that the two samples come\n * from the same distribution in favor of the alternative that one is shifted with\n * respect to the other.\n *\n * @param {Array<number>} sampleX a sample as an array of numbers\n * @param {Array<number>} sampleY a sample as an array of numbers\n * @returns {number} rank sum for sampleX\n *\n * @example\n * wilcoxonRankSum([1, 4, 8], [9, 12, 15]); // => 6\n */\nfunction wilcoxonRankSum(sampleX, sampleY) {\n    if (!sampleX.length || !sampleY.length) {\n        throw new Error(\"Neither sample can be empty\");\n    }\n\n    const pooledSamples = sampleX\n        .map((x) => ({ label: \"x\", value: x }))\n        .concat(sampleY.map((y) => ({ label: \"y\", value: y })))\n        .sort((a, b) => a.value - b.value);\n\n    for (let rank = 0; rank < pooledSamples.length; rank++) {\n        pooledSamples[rank].rank = rank;\n    }\n\n    let tiedRanks = [pooledSamples[0].rank];\n    for (let i = 1; i < pooledSamples.length; i++) {\n        if (pooledSamples[i].value === pooledSamples[i - 1].value) {\n            tiedRanks.push(pooledSamples[i].rank);\n            if (i === pooledSamples.length - 1) {\n                replaceRanksInPlace(pooledSamples, tiedRanks);\n            }\n        } else if (tiedRanks.length > 1) {\n            replaceRanksInPlace(pooledSamples, tiedRanks);\n        } else {\n            tiedRanks = [pooledSamples[i].rank];\n        }\n    }\n\n    function replaceRanksInPlace(pooledSamples, tiedRanks) {\n        const average = (tiedRanks[0] + tiedRanks[tiedRanks.length - 1]) / 2;\n        for (let i = 0; i < tiedRanks.length; i++) {\n            pooledSamples[tiedRanks[i]].rank = average;\n        }\n    }\n\n    let rankSum = 0;\n\n    for (let i = 0; i < pooledSamples.length; i++) {\n        const sample = pooledSamples[i];\n        if (sample.label === \"x\") {\n            rankSum += sample.rank + 1;\n        }\n    }\n\n    return rankSum;\n}\n\nexport default wilcoxonRankSum;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,eAAeA,CAACC,OAAO,EAAEC,OAAO,EAAE;EACvC,IAAI,CAACD,OAAO,CAACE,MAAM,IAAI,CAACD,OAAO,CAACC,MAAM,EAAE;IACpC,MAAM,IAAIC,KAAK,CAAC,6BAA6B,CAAC;EAClD;EAEA,MAAMC,aAAa,GAAGJ,OAAO,CACxBK,GAAG,CAAEC,CAAC,KAAM;IAAEC,KAAK,EAAE,GAAG;IAAEC,KAAK,EAAEF;EAAE,CAAC,CAAC,CAAC,CACtCG,MAAM,CAACR,OAAO,CAACI,GAAG,CAAEK,CAAC,KAAM;IAAEH,KAAK,EAAE,GAAG;IAAEC,KAAK,EAAEE;EAAE,CAAC,CAAC,CAAC,CAAC,CACtDC,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACJ,KAAK,GAAGK,CAAC,CAACL,KAAK,CAAC;EAEtC,KAAK,IAAIM,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGV,aAAa,CAACF,MAAM,EAAEY,IAAI,EAAE,EAAE;IACpDV,aAAa,CAACU,IAAI,CAAC,CAACA,IAAI,GAAGA,IAAI;EACnC;EAEA,IAAIC,SAAS,GAAG,CAACX,aAAa,CAAC,CAAC,CAAC,CAACU,IAAI,CAAC;EACvC,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,aAAa,CAACF,MAAM,EAAEc,CAAC,EAAE,EAAE;IAC3C,IAAIZ,aAAa,CAACY,CAAC,CAAC,CAACR,KAAK,KAAKJ,aAAa,CAACY,CAAC,GAAG,CAAC,CAAC,CAACR,KAAK,EAAE;MACvDO,SAAS,CAACE,IAAI,CAACb,aAAa,CAACY,CAAC,CAAC,CAACF,IAAI,CAAC;MACrC,IAAIE,CAAC,KAAKZ,aAAa,CAACF,MAAM,GAAG,CAAC,EAAE;QAChCgB,mBAAmB,CAACd,aAAa,EAAEW,SAAS,CAAC;MACjD;IACJ,CAAC,MAAM,IAAIA,SAAS,CAACb,MAAM,GAAG,CAAC,EAAE;MAC7BgB,mBAAmB,CAACd,aAAa,EAAEW,SAAS,CAAC;IACjD,CAAC,MAAM;MACHA,SAAS,GAAG,CAACX,aAAa,CAACY,CAAC,CAAC,CAACF,IAAI,CAAC;IACvC;EACJ;EAEA,SAASI,mBAAmBA,CAACd,aAAa,EAAEW,SAAS,EAAE;IACnD,MAAMI,OAAO,GAAG,CAACJ,SAAS,CAAC,CAAC,CAAC,GAAGA,SAAS,CAACA,SAAS,CAACb,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC;IACpE,KAAK,IAAIc,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,SAAS,CAACb,MAAM,EAAEc,CAAC,EAAE,EAAE;MACvCZ,aAAa,CAACW,SAAS,CAACC,CAAC,CAAC,CAAC,CAACF,IAAI,GAAGK,OAAO;IAC9C;EACJ;EAEA,IAAIC,OAAO,GAAG,CAAC;EAEf,KAAK,IAAIJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,aAAa,CAACF,MAAM,EAAEc,CAAC,EAAE,EAAE;IAC3C,MAAMK,MAAM,GAAGjB,aAAa,CAACY,CAAC,CAAC;IAC/B,IAAIK,MAAM,CAACd,KAAK,KAAK,GAAG,EAAE;MACtBa,OAAO,IAAIC,MAAM,CAACP,IAAI,GAAG,CAAC;IAC9B;EACJ;EAEA,OAAOM,OAAO;AAClB;AAEA,eAAerB,eAAe","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}